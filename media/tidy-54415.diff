diff --git a/README.md b/README.md
index 67148cd..a9089f9 100644
--- a/README.md
+++ b/README.md
@@ -2,6 +2,6 @@
 InkBox OS init program. Is launched by BusyBox from `/etc/inittab` reference.
 ## Compilation
 ```
-armv7l-linux-musleabihf-gcc init.c -o init -static -D_GNU_SOURCE
+armv7l-linux-musleabihf-gcc init.c -o init -static
 armv7l-linux-musleabihf-strip init
 ```
diff --git a/init.c b/init.c
index 7c068a1..4cb9525 100644
--- a/init.c
+++ b/init.c
@@ -1,42 +1,52 @@
 #include "init.h"
 
-int main() {
+int main(void) {
 	// Device identification
 	device = read_file("/opt/device", true);
+	if (!device) {
+		device = alloca(8);
+		if (!device) {
+			// You've got bigger problems than no init if alloca failed...
+			fprintf(stderr, "alloca failed\n");
+			exit(EXIT_FAILURE);
+		}
+		strcpy(device, "UNKNOWN");
+	}
 
 	// TTY device
-	if(strstr(device, "emu")) {
-		tty = "ttyAMA0";
-	}
-	else if(strstr(device, "bpi")) {
-		tty = "ttyS0";
-	}
-	else {
-		tty = "ttymxc0";
+	if (MATCH(device, "emu")) {
+		strcpy(tty, "ttyAMA0");
+	} else if (MATCH(device, "bpi")) {
+		strcpy(tty, "ttyS0");
+	} else {
+		strcpy(tty, "ttymxc0");
 	}
 
 	// Filesystems
-	mount("proc", "/proc", "proc", MS_NOSUID, "");
-	mount("sysfs", "/sys", "sysfs", 0, "");
+	MOUNT("proc", "/proc", "proc", MS_NOSUID, "");
+	MOUNT("sysfs", "/sys", "sysfs", 0, "");
 	// Prevent unpriviledged users to read and write to sysfs by default
 	{
-		const char * arguments[] = { "/bin/sh", "-c", "find /sys -type f -print0 | xargs -0 chmod 700", NULL }; run_command("/bin/sh", arguments, true);
+		const char * const arguments[] = { "/bin/sh", "-c", "find /sys -type f -print0 | xargs -0 chmod 700", NULL };
+		run_command("/bin/sh", arguments, true);
 	}
-	sleep(1);
-	mount("devtmpfs", "/dev", "devtmpfs", 0, "");
-	mount("tmpfs", "/tmp", "tmpfs", 0, "size=16M");
+	sleep(1); // ??!!
+	MOUNT("devtmpfs", "/dev", "devtmpfs", 0, "");
+	MOUNT("tmpfs", "/tmp", "tmpfs", 0, "size=16M");
 
 	// Kobo Clara HD (N249) handling
-	if(strstr(device, "n249")) {
+	if(MATCH(device, "n249")) {
 		// Unsquashing modules
 		{
-			const char * arguments[] = { "/usr/bin/unsquashfs", "-d", "/lib/modules", "/opt/modules.sqsh", NULL }; run_command("/usr/bin/unsquashfs", arguments, true);
+			const char * const arguments[] = { "/usr/bin/unsquashfs", "-d", "/lib/modules", "/opt/modules.sqsh", NULL };
+			run_command("/usr/bin/unsquashfs", arguments, true);
 		}
 
 		// Put epdc.fw in the right place
 		mkpath("/lib/firmware/imx", 0755);
 		{
-			const char * arguments[] = { "/usr/bin/unsquashfs", "-d", "/lib/firmware/imx/epdc", "/opt/firmware.sqsh", NULL }; run_command("/usr/bin/unsquashfs", arguments, true);
+			const char * const arguments[] = { "/usr/bin/unsquashfs", "-d", "/lib/firmware/imx/epdc", "/opt/firmware.sqsh", NULL };
+			run_command("/usr/bin/unsquashfs", arguments, true);
 		}
 
 		// Load some modules
@@ -46,20 +56,21 @@ int main() {
 	}
 
 	// Kindle Touch (KT) handling
-	if(strstr(device, "kt")) {
+	if(MATCH(device, "kt")) {
 		// Unsquashing modules
 		{
-			const char * arguments[] = { "/usr/bin/unsquashfs", "-d", "/lib/modules", "/opt/modules.sqsh", NULL }; run_command("/usr/bin/unsquashfs", arguments, true);
+			const char * const arguments[] = { "/usr/bin/unsquashfs", "-d", "/lib/modules", "/opt/modules.sqsh", NULL };
+			run_command("/usr/bin/unsquashfs", arguments, true);
 		}
 
 		// Loading framebuffer modules
 		// eink_fb_waveform
 		load_module("/lib/modules/2.6.35-inkbox/kernel/drivers/video/eink/waveform/eink_fb_waveform.ko", "");
 		// Mounting P1 of MMC to retrieve FB waveform
-		mount("/dev/mmcblk0p1", "/mnt", "ext4", 0, "");
+		MOUNT("/dev/mmcblk0p1", "/mnt", "ext4", 0, "");
 		// Check if waveform data exists
 		// mxc_epdc_fb
-		if(file_exists("/mnt/waveform/waveform.wbf") && file_exists("/mnt/waveform/waveform.wrf")) {
+		if(FILE_EXISTS("/mnt/waveform/waveform.wbf") && FILE_EXISTS("/mnt/waveform/waveform.wrf")) {
 			// Use device waveform
 			load_module("/lib/modules/2.6.35-inkbox/kernel/drivers/video/mxc/mxc_epdc_fb.ko", "default_panel_hw_init=1 default_update_mode=1 waveform_to_use=/mnt/waveform/waveform.wbf");
 		}
@@ -73,46 +84,34 @@ int main() {
 		{
 			// Refresh screen twice to initialize FB module properly
 			for(int i = 0; i < 2; i++) {
-				const char * arguments[] = { "/usr/bin/fbink", "-k", "-f", "-w", "-q", NULL }; run_command("/usr/bin/fbink", arguments, true);
+				const char * const arguments[] = { "/usr/bin/fbink", "-k", "-f", "-w", "-q", NULL };
+				run_command("/usr/bin/fbink", arguments, true);
 			}
 		}
 	}
 
 	// Setting hostname
-	char hostname[6] = "inkbox";
-	sethostname(hostname, sizeof(hostname));
+	sethostname("inkbox", 6);
 
 	// Setting loopack interface UP
 	set_if_up("lo");
 
-	// Getting kernel information
-	// Kernel version
-	struct utsname uname_data;
-	uname(&uname_data);
-	// Pass 0 to snprintf to let it tell us how large of a buffer we need
-	int size = snprintf(kernel_version, 0U, "%s %s %s", uname_data.sysname, uname_data.nodename, uname_data.version);
-	if (size < 0) {
-		// snprintf said no! handle it!
-	}
-	else {
-		kernel_version = alloca(size + 1U); // We need a trailing NULL
-		if (snprintf(kernel_version, size, "%s %s %s", uname_data.sysname, uname_data.nodename, uname_data.version) < 0) {
-			// snprintf said no again! handle it!
-		}
-	}
-	// Kernel build ID
-	kernel_build_id = read_file("/opt/build_id", true);
-	// Kernel Git commit
-	kernel_git_commit = read_file("/opt/commit", true);
 	// Setting up boot flags partition (P1)
-	mount("/dev/mmcblk0p1", "/mnt", "ext4", 0, "");
+	MOUNT("/dev/mmcblk0p1", "/mnt", "ext4", 0, "");
 	mkpath("/mnt/flags", 0755);
 
 	// Handling DISPLAY_DEBUG flag (https://inkbox.ddns.net/wiki/index.php?title=Boot_flags)
-	display_debug = read_file("/mnt/flags/DISPLAY_DEBUG", true);
-	if(strstr(display_debug, "true")) {
+	char * display_debug = read_file("/mnt/flags/DISPLAY_DEBUG", true);
+	bool is_display_debug = false;
+	if (MATCH(display_debug, "true")) {
+		is_display_debug = true;
+	}
+	free(display_debug);
+	display_debug = NULL;
+	if(is_display_debug) {
 		mkfifo(SERIAL_FIFO_PATH, 0x29A);
-		const char * arguments[] = { "/etc/init.d/inkbox-splash", "display_debug", NULL }; run_command("/etc/init.d/inkbox-splash", arguments, false);
+		const char * const arguments[] = { "/etc/init.d/inkbox-splash", "display_debug", NULL };
+		run_command("/etc/init.d/inkbox-splash", arguments, false);
 		sleep(5);
 		// Redirecting all stdout output to display debug's named pipe
 		freopen(SERIAL_FIFO_PATH, "a+", stdout);
@@ -122,17 +121,69 @@ int main() {
 	usbnet_ip = read_file("/mnt/flags/USBNET_IP", true);
 	
 	// MOUNT_RW
-	mount_rw = read_file("/mnt/flags/MOUNT_RW", true);
+	char * mount_rw = read_file("/mnt/flags/MOUNT_RW", true);
+	bool is_mount_rw = false;
+	if (MATCH(mount_rw, "true")) {
+		is_mount_rw = true;
+	}
+	free(mount_rw);
+	mount_rw = NULL;
 
 	// LOGIN_SHELL
-	login_shell = read_file("/mnt/flags/LOGIN_SHELL", true);
+	char * login_shell = read_file("/mnt/flags/LOGIN_SHELL", true);
 
 	// X11_START
-	x11_start = read_file("/mnt/flags/X11_START", true);
+	char * x11_start = read_file("/mnt/flags/X11_START", true);
+	bool with_x11 = false;
+	if (MATCH(x11_start, "true")) {
+		with_x11 = true;
+	}
+	free(x11_start);
+	x11_start = NULL;
 
 	// Information header
+	// Getting kernel information
+	// Kernel version
+	struct utsname uname_data;
+	uname(&uname_data);
+	char * kernel_version = NULL;
+	// Pass 0 to snprintf to let it tell us how large of a buffer we need
+	int size = snprintf(kernel_version, 0U, "%s %s %s", uname_data.sysname, uname_data.nodename, uname_data.version);
+	if (size < 0) {
+		kernel_version = strdupa("UKNOWN");
+		if (!kernel_version) {
+			perror("strdupa");
+			exit(EXIT_FAILURE);
+		}
+	} else {
+		kernel_version = alloca((size_t) size + 1U); // We need a trailing NULL
+		if (!kernel_version) {
+			fprintf(stderr, "alloca failed\n");
+			exit(EXIT_FAILURE);
+		}
+		if (snprintf(kernel_version, (size_t) size, "%s %s %s", uname_data.sysname, uname_data.nodename, uname_data.version) < 0) {
+			perror("snprintf");
+
+			// Fallback
+			kernel_version = strdupa("UKNOWN");
+			if (!kernel_version) {
+				perror("strdupa");
+				exit(EXIT_FAILURE);
+			}
+		}
+	}
+	// Kernel build ID
+	char * kernel_build_id = read_file("/opt/build_id", true);
+	// Kernel Git commit
+	char * kernel_git_commit = read_file("/opt/commit", true);
 	printf("\n%s GNU/Linux\nInkBox OS, kernel build %s, commit %s\n\n", kernel_version, kernel_build_id, kernel_git_commit);
 	printf("Copyright (C) 2021-2023 Nicolas Mailloux <nicolecrivain@gmail.com>\n");
+	free(kernel_git_commit);
+	kernel_git_commit = NULL;
+	free(kernel_build_id);
+	kernel_build_id = NULL;
+	free(kernel_version);
+	kernel_version = NULL;
 
 	// Checking filesystems
 	info("Checking filesystems ...", INFO_OK);
@@ -141,52 +192,55 @@ int main() {
 	printf("\n");
 	{
 		// P1
-		const char * arguments[] = { "/usr/bin/fsck.ext4", "-y", "/dev/mmcblk0p1", NULL };
+		const char * const arguments[] = { "/usr/bin/fsck.ext4", "-y", "/dev/mmcblk0p1", NULL };
 		run_command("/usr/bin/fsck.ext4", arguments, true);
 	}
 	{
 		// P2
-		if (strstr(device, "n873")) {
-                       const char * arguments[] = { "/usr/bin/fsck.ext4", "-y", "/dev/mmcblk0p5", NULL };
+		if (MATCH(device, "n873")) {
+                       const char * const arguments[] = { "/usr/bin/fsck.ext4", "-y", "/dev/mmcblk0p5", NULL };
                        run_command("/usr/bin/fsck.ext4", arguments, true);
 		}
 		else {
-                       const char * arguments[] = { "/usr/bin/fsck.ext4", "-y", "/dev/mmcblk0p2", NULL };
+                       const char * const arguments[] = { "/usr/bin/fsck.ext4", "-y", "/dev/mmcblk0p2", NULL };
                        run_command("/usr/bin/fsck.ext4", arguments, true);
 		}
 	}
 	{
 		// P3
-		const char * arguments[] = { "/usr/bin/fsck.ext4", "-y", "/dev/mmcblk0p3", NULL };
+		const char * const arguments[] = { "/usr/bin/fsck.ext4", "-y", "/dev/mmcblk0p3", NULL };
 		run_command("/usr/bin/fsck.ext4", arguments, true);
 	}
 	{
 		// P4
-		const char * arguments[] = { "/usr/bin/fsck.ext4", "-y", "/dev/mmcblk0p4", NULL };
+		const char * const arguments[] = { "/usr/bin/fsck.ext4", "-y", "/dev/mmcblk0p4", NULL };
 		run_command("/usr/bin/fsck.ext4", arguments, true);
 	}
 	printf("\n");
 	// Remounting P1
-	mount("/dev/mmcblk0p1", "/mnt", "ext4", 0, "");
+	MOUNT("/dev/mmcblk0p1", "/mnt", "ext4", 0, "");
 
 	// Universal ID check
 	{
-		const char * arguments[] = { "/opt/bin/uidgen", NULL }; run_command("/opt/bin/uidgen", arguments, true);
+		const char * const arguments[] = { "/opt/bin/uidgen", NULL };
+		run_command("/opt/bin/uidgen", arguments, true);
 	}
 
 	// DONT_BOOT
-	dont_boot = read_file("/mnt/flags/DONT_BOOT", true);
-	if(strstr(dont_boot, "true")) {
+	char * dont_boot = read_file("/mnt/flags/DONT_BOOT", true);
+	if(MATCH(dont_boot, "true")) {
 		info("Device is locked down and will not boot", INFO_FATAL);
 		show_alert_splash(1, false);
 		exit(EXIT_FAILURE);
 	}
+	free(dont_boot);
+	dont_boot = NULL;
 
 	// ENCRYPT_LOCK
-	encrypt_lock = read_file("/mnt/flags/ENCRYPT_LOCK", true);
-	if(encrypt_lock[0] != '\0') {
-		unsigned long current_epoch = time(NULL);
-		unsigned long lock_epoch = strtoul(encrypt_lock, NULL, 0);
+	char * encrypt_lock = read_file("/mnt/flags/ENCRYPT_LOCK", true);
+	if(encrypt_lock) {
+		time_t current_epoch = time(NULL);
+		long lock_epoch = strtol(encrypt_lock, NULL, 0);
 		// Comparing lockdown time limit to current time
 		if(current_epoch < lock_epoch) {
 			info("Too many incorrect encrypted storage unlocking attempts have locked down this device. Shutting down ...", INFO_FATAL);
@@ -201,6 +255,8 @@ int main() {
 			remove("/mnt/flags/ENCRYPT_LOCK");
 		}
 	}
+	free(encrypt_lock);
+	encrypt_lock = NULL;
 
 	// Unmounting boot flags partition
 	umount("/mnt");
@@ -208,42 +264,53 @@ int main() {
 	// Are we spawning a shell?
 	// https://stackoverflow.com/a/19186027/14164574
 	{
-		struct timeval tmo;
-		fd_set readfds;
-
 		printf("(initrd) Hit ENTER to stop auto-boot ... ");
 		fflush(stdout);
 
-		// Wait only 3 seconds for user input
-		FD_ZERO(&readfds);
-		FD_SET(0, &readfds);
-		tmo.tv_sec = 3;
-		tmo.tv_usec = 0;
+		struct pollfd pfd   = { 0 };
+		pfd.fd              = fileno(stdin);
+		pfd.events          = POLLIN;
+		pfd.revents         = 0;
+
+		while (true) {
+			// Wait only 3 seconds for user input
+			int poll_num = poll(&pfd, 1, 3 * 1000);
+			if (poll_num == -1) {
+				if (errno == EINTR) {
+					continue;
+				}
+				perror("poll");
+				exit(EXIT_FAILURE);
+			}
+
+			if (poll_num > 0) {
+				// Drain stdin first
+				char buf[PIPE_BUF]; // stdin should be line-buffered if it's a terminal, that should be more than large enough
+				read(pfd.fd, buf, sizeof(buf));
 
-		switch(select(1, &readfds, NULL, NULL, &tmo)) {
-			case -1:
+				setup_shell();
 				break;
-			case 0:
+			}
+
+			if (poll_num == 0) {
+				// Timed out
 				printf("\n\n");
-				goto boot;
+				break;
+			}
 		}
-
-		// This is only executed if the Enter key has been pressed
-		setup_shell();
 	}
 
-	boot:;
 	// Checking if the 'root' flag is set
+	bool root_mmc = false;
 	{
+		char root_flag[ROOT_FLAG_SIZE] = { 0 };
 		// MMC
-		if(strstr(device, "kt")) {
-			read_sector("/dev/mmcblk0", ROOT_FLAG_SECTOR_KT, 512, ROOT_FLAG_SIZE);
+		if(MATCH(device, "kt")) {
+			read_sector(root_flag, sizeof(root_flag), "/dev/mmcblk0", ROOT_FLAG_SECTOR_KT, 512);
 		}
 		else {
-			read_sector("/dev/mmcblk0", ROOT_FLAG_SECTOR, 512, ROOT_FLAG_SIZE);
+			read_sector(root_flag, sizeof(root_flag), "/dev/mmcblk0", ROOT_FLAG_SECTOR, 512);
 		}
-		char root_flag[ROOT_FLAG_SIZE] = { 0 };
-		memcpy(root_flag, sector_content, ROOT_FLAG_SIZE);
 
 		if(memcmp(root_flag, "rooted", ROOT_FLAG_SIZE) == 0) {
 			root_mmc = true;
@@ -252,24 +319,26 @@ int main() {
 			root_mmc = false;
 		}
 	}
+	bool root_initrd = false;
 	{
 		// Init ramdisk
 		char * root_flag = read_file("/opt/root", true);
-		if(strstr(root_flag, "rooted")) {
+		if(MATCH(root_flag, "rooted")) {
 			root_initrd = true;
 		}
 		else {
 			root_initrd = false;
 		}
+		free(root_flag);
 	}
 
-	if(root_mmc == true && root_initrd == true) {
+	if(root_mmc && root_initrd) {
 		root = true;
 	}
 	else {
 		root = false;
-		if(root_mmc == true || root_initrd == true) {
-			mount("/dev/mmcblk0p1", "/mnt", "ext4", 0, "");
+		if(root_mmc || root_initrd) {
+			MOUNT("/dev/mmcblk0p1", "/mnt", "ext4", 0, "");
 			write_file("/mnt/flags/DONT_BOOT", "true\n");
 			sync();
 			umount("/mnt");
@@ -279,79 +348,110 @@ int main() {
 		}
 	}
 
-	if(root == true) {
+	if(root) {
 		info("Device is rooted; not enforcing security policy", INFO_WARNING);
 	}
 	else {
 		info("Device is not rooted; enforcing security policy", INFO_OK);
 	}
 
+	bool power_button_pressed = false;
+	bool other_button_pressed = false;
 	{
 		// Allow 3 seconds for power button input (boot mode & DFL mode)
 		int fd = open(BUTTON_INPUT_DEVICE, O_RDONLY | O_NONBLOCK);
-		struct input_event ev;
-		time_t monitor_input_start = time(NULL);
-		while(time(NULL) - monitor_input_start <= 3) {
-			if(read(fd, &ev, sizeof(struct input_event)) > 0) {
-				if(ev.code == KEY_POWER) {
-					power_button_pressed = true;
-				}
-				// KEY_KATAKANA represents the brightness button on the Glo (N613)
-				else if(ev.code == KEY_HOME || ev.code == KEY_KATAKANA) {
-					other_button_pressed = true;
+		if (fd == -1) {
+			perror("open");
+			exit(EXIT_FAILURE);
+		}
+
+		fd_set rfds;
+		FD_ZERO(&rfds);
+		FD_SET((unsigned int) fd, &rfds);
+		struct timeval tv;
+		tv.tv_sec = 3;
+		tv.tv_usec = 0;
+
+		while (true) {
+			// Linux modifies tv to reflect the amount of time not slept (i.e., the amount of time left in the timeout),
+			// we rely on that to only loop for 3s max without having to compute anything ourselves.
+			int rv = select(1, &rfds, NULL, NULL, &tv);
+
+			if (rv == -1 && errno != EINTR) {
+				perror("select");
+				exit(EXIT_FAILURE);
+			} else if (rv) {
+				struct input_event ev;
+				if(read(fd, &ev, sizeof(ev)) == sizeof(ev)) {
+					if(ev.code == KEY_POWER && ev.value == 1) {
+						power_button_pressed = true;
+					}
+					// KEY_KATAKANA represents the brightness button on the Glo (N613)
+					else if((ev.code == KEY_HOME || ev.code == KEY_KATAKANA) && ev.value == 1) {
+						other_button_pressed = true;
+					}
 				}
+			} else {
+				// Timeout
+				break;
 			}
 		}
+
+		close(fd);
 	}
 
 	// Mounting boot flags partition
-	mount("/dev/mmcblk0p1", "/mnt", "ext4", 0, "");
+	MOUNT("/dev/mmcblk0p1", "/mnt", "ext4", 0, "");
 
 	// DFL mode
-	if(root == true) {
-		dfl = read_file("/mnt/flags/DFL", true);
-		if((power_button_pressed == true && other_button_pressed == true) || (strstr(dfl, "true"))) {
+	if(root) {
+		char * dfl = read_file("/mnt/flags/DFL", true);
+		if((power_button_pressed && other_button_pressed) || MATCH(dfl, "true")) {
 			info("Entering Direct Firmware Loader mode (DFL) ...", INFO_OK);
 			// Re-setting flag
 			write_file("/mnt/flags/DFL", "false\n");
 			launch_dfl();
 		}
+		free(dfl);
 	}
 
 	// BOOT_USB_DEBUG
-	if(root == true) {
-		boot_usb_debug = read_file("/mnt/flags/BOOT_USB_DEBUG", true);
-		if(strstr(boot_usb_debug, "true")) {
+	if(root) {
+		char * boot_usb_debug = read_file("/mnt/flags/BOOT_USB_DEBUG", true);
+		if(MATCH(boot_usb_debug, "true")) {
 			info("Starting init ramdisk boot USB debug framework", INFO_OK);
 			// Re-setting flag
 			write_file("/mnt/flags/BOOT_USB_DEBUG", "false\n");
 			setup_usb_debug(true);
 		}
+		free(boot_usb_debug);
 	}
 
 	// DIAGS_BOOT
-	diags_boot = read_file("/mnt/flags/DIAGS_BOOT", true);
+	char * diags_boot = read_file("/mnt/flags/DIAGS_BOOT", true);
 
 	// INITRD_DEBUG
-	if(root == true) {
-		initrd_debug = read_file("/mnt/flags/INITRD_DEBUG", true);
-		if(strstr(initrd_debug, "true")) {
+	if(root) {
+		char * initrd_debug = read_file("/mnt/flags/INITRD_DEBUG", true);
+		if(MATCH(initrd_debug, "true")) {
 			info("Starting init ramdisk USB debug framework", INFO_OK);
 			setup_usb_debug(false);
 		}
+		free(initrd_debug);
 	}
 
 	// Unmounting boot flags partition
         umount("/mnt");
 
 	// Handling boot mode switching
-	if(power_button_pressed == true) {
+	int boot_mode = BOOT_STANDARD;
+	if(power_button_pressed) {
 		boot_mode = BOOT_DIAGNOSTICS;
 		info("Power button input detected", INFO_WARNING);
 		info("Boot mode: Diagnostics", INFO_OK);
 	}
 	else {
-		if(strstr(diags_boot, "true")) {
+		if(MATCH(diags_boot, "true")) {
 			boot_mode = BOOT_DIAGNOSTICS;
 			info("Boot mode: Diagnostics", INFO_OK);
 		}
@@ -360,28 +460,35 @@ int main() {
 			info("Boot mode: Standard", INFO_OK);
 		}
 	}
+	free(diags_boot);
+	diags_boot = NULL;
 
+	bool do_update = false;
 	if(boot_mode == BOOT_STANDARD) {
 		// Standard mode
 		// Checking whether we need to show an update splash or not
-		if(!(strstr(display_debug, "true"))) {
+		if(!is_display_debug) {
 			// WILL_UPDATE flag
-			mount("/dev/mmcblk0p1", "/mnt", "ext4", 0, "");
-			will_update = read_file("/mnt/flags/WILL_UPDATE", true);
+			MOUNT("/dev/mmcblk0p1", "/mnt", "ext4", 0, "");
+			char * will_update = read_file("/mnt/flags/WILL_UPDATE", true);
 			umount("/mnt");
 
-			if(strstr(will_update, "true")) {
-				const char * arguments[] = { "/etc/init.d/inkbox-splash", "update_splash", NULL }; update_splash_pid = run_command("/etc/init.d/inkbox-splash", arguments, false);
+			if(MATCH(will_update, "true")) {
+				do_update = true;
+				const char * const arguments[] = { "/etc/init.d/inkbox-splash", "update_splash", NULL };
+				run_command("/etc/init.d/inkbox-splash", arguments, false);
 			}
 			else {
 				{
 					// Showing 'InkBox' splash
-					const char * arguments[] = { "/etc/init.d/inkbox-splash", NULL }; run_command("/etc/init.d/inkbox-splash", arguments, true);
+					const char * const arguments[] = { "/etc/init.d/inkbox-splash", NULL };
+					run_command("/etc/init.d/inkbox-splash", arguments, true);
 					sleep(2);
 				}
 				{
 					// Initializing progress bar
-					const char * arguments[] = { "/etc/init.d/inkbox-splash", "progress_bar_init", NULL }; run_command("/etc/init.d/inkbox-splash", arguments, false);
+					const char * const arguments[] = { "/etc/init.d/inkbox-splash", "progress_bar_init", NULL };
+					run_command("/etc/init.d/inkbox-splash", arguments, false);
 					sleep(2);
 
 					set_progress(0);
@@ -390,21 +497,22 @@ int main() {
 					progress_sleep();
 				}
 			}
+			free(will_update);
 		}
 
 		// Mounting root filesystem
-		if(strstr(mount_rw, "true")) {
+		if(is_mount_rw) {
 			// Mounting read-write
-			const char * arguments[] = { "/etc/init.d/overlay-mount", "rw", NULL };
-			int exit_code =	run_command("/etc/init.d/overlay-mount", arguments, true);
+			const char * const arguments[] = { "/etc/init.d/overlay-mount", "rw", NULL };
+			long int exit_code = run_command("/etc/init.d/overlay-mount", arguments, true);
 			if(exit_code != 0) {
 				exit(exit_code);
 			}
 		}
 		else {
 			// Mounting read-only (default)
-			const char * arguments[] = { "/etc/init.d/overlay-mount", "ro", NULL };
-			int exit_code = run_command("/etc/init.d/overlay-mount", arguments, true);
+			const char * const arguments[] = { "/etc/init.d/overlay-mount", "ro", NULL };
+			long int exit_code = run_command("/etc/init.d/overlay-mount", arguments, true);
 			if(exit_code != 0) {
 				exit(exit_code);
 			}
@@ -415,75 +523,82 @@ int main() {
 		progress_sleep();
 
 		// Mounting P1 in root filesystem
-		mount("/dev/mmcblk0p1", "/mnt/boot", "ext4", 0, "");
-		mount("tmpfs", "/mnt/root", "tmpfs", 0, "size=8M");
+		MOUNT("/dev/mmcblk0p1", "/mnt/boot", "ext4", 0, "");
+		MOUNT("tmpfs", "/mnt/root", "tmpfs", 0, "size=8M");
 
 		// Handling LOGIN_SHELL
-		if(root == true) {
-			if(strstr(login_shell, "bash")) {
+		if(root) {
+			if(MATCH(login_shell, "bash")) {
 				{
-					const char * arguments[] = { "/bin/sed", "-i", "1s#.*#root:x:0:0:root:/root:/bin/bash#", "/opt/passwd_root", NULL }; run_command("/bin/sed", arguments, true);
+					const char * const arguments[] = { "/bin/sed", "-i", "1s#.*#root:x:0:0:root:/root:/bin/bash#", "/opt/passwd_root", NULL };
+					run_command("/bin/sed", arguments, true);
 				}
 				{
-					const char * arguments[] = { "/bin/sed", "-i", "30s#.*#user:x:1000:1000:Linux User,,,:/:/bin/bash#", "/opt/passwd_root", NULL }; run_command("/bin/sed", arguments, true);
+					const char * const arguments[] = { "/bin/sed", "-i", "30s#.*#user:x:1000:1000:Linux User,,,:/:/bin/bash#", "/opt/passwd_root", NULL };
+					run_command("/bin/sed", arguments, true);
 				}
 			}
-			else if(strstr(login_shell, "zsh")) {
+			else if(MATCH(login_shell, "zsh")) {
 				{
-					const char * arguments[] = { "/bin/sed", "-i", "1s#.*#root:x:0:0:root:/root:/usr/local/bin/zsh#", "/opt/passwd_root", NULL }; run_command("/bin/sed", arguments, true);
+					const char * const arguments[] = { "/bin/sed", "-i", "1s#.*#root:x:0:0:root:/root:/usr/local/bin/zsh#", "/opt/passwd_root", NULL };
+					run_command("/bin/sed", arguments, true);
 				}
 				{
-					const char * arguments[] = { "/bin/sed", "-i", "30s#.*#user:x:1000:1000:Linux User,,,:/:/usr/local/bin/zsh#", "/opt/passwd_root", NULL }; run_command("/bin/sed", arguments, true);
+					const char * const arguments[] = { "/bin/sed", "-i", "30s#.*#user:x:1000:1000:Linux User,,,:/:/usr/local/bin/zsh#", "/opt/passwd_root", NULL };
+					run_command("/bin/sed", arguments, true);
 				}
 			}
-			else if(strstr(login_shell, "fish")) {
+			else if(MATCH(login_shell, "fish")) {
 				{
-					const char * arguments[] = { "/bin/sed", "-i", "1s#.*#root:x:0:0:root:/root:/usr/bin/fish#", "/opt/passwd_root", NULL }; run_command("/bin/sed", arguments, true);
+					const char * const arguments[] = { "/bin/sed", "-i", "1s#.*#root:x:0:0:root:/root:/usr/bin/fish#", "/opt/passwd_root", NULL };
+					run_command("/bin/sed", arguments, true);
 				}
 				{
-					const char * arguments[] = { "/bin/sed", "-i", "30s#.*#user:x:1000:1000:Linux User,,,:/:/usr/bin/fish#", "/opt/passwd_root", NULL }; run_command("/bin/sed", arguments, true);
+					const char * const arguments[] = { "/bin/sed", "-i", "30s#.*#user:x:1000:1000:Linux User,,,:/:/usr/bin/fish#", "/opt/passwd_root", NULL };
+					run_command("/bin/sed", arguments, true);
 				}
 				mkpath("/mnt/root/.config", 0755);
 				mkpath("/mnt/root/.config/fish", 0755);
 				write_file("/mnt/root/.config/fish/fish_variables", "# This file contains fish universal variable definitions.\n# VERSION: 3.0\nSETUVAR __fish_init_2_3_0:\\x1d\nSETUVAR __fish_init_3_x:\\x1d\nSETUVAR --export fish_user_paths:/usr/local/bin");
 			}
 			else {
-				if(!(strstr(login_shell, "")) && !(strstr(login_shell, "ash"))) {
+				if(NOT_MATCH(login_shell, "") && NOT_MATCH(login_shell, "ash")) {
 					char message_buff[256] = { 0 };
 					snprintf(message_buff, sizeof(message_buff), "'%s' is not a valid login shell; falling back to default", login_shell);
 					info(message_buff, INFO_WARNING);
 				}
 			}
 		}
+		free(login_shell);
+		login_shell = NULL;
 
 		// passwd file
 		// Bind-mounting directly from initrd filesystem does not seem to work; copying file to temporary filesystem
 		copy_file("/opt/passwd_root", "/tmp/passwd");
-		mount("/tmp/passwd", "/mnt/etc/passwd", "", MS_BIND, "");
-
+		MOUNT("/tmp/passwd", "/mnt/etc/passwd", "", MS_BIND, "");
 		// User storage
-		mount("/dev/mmcblk0p4", "/mnt/opt/storage", "ext4", 0, "");
+		MOUNT("/dev/mmcblk0p4", "/mnt/opt/storage", "ext4", 0, "");
 		// Configuration files
 		mkpath("/mnt/opt/storage/config", 0755);
-		mount("/mnt/opt/storage/config", "/mnt/opt/config", "", MS_BIND, "");
+		MOUNT("/mnt/opt/storage/config", "/mnt/opt/config", "", MS_BIND, "");
 		// GUI bundle
 		mkpath("/mnt/opt/storage/update", 0755);
-		mount("/mnt/opt/storage/update", "/mnt/opt/update", "", MS_BIND, "");
+		MOUNT("/mnt/opt/storage/update", "/mnt/opt/update", "", MS_BIND, "");
 		// X11/KoBox
 		mkpath("/mnt/opt/storage/X11/rootfs/work", 0755);
 		mkpath("/mnt/opt/storage/X11/rootfs/write", 0755);
-		mount("/mnt/opt/storage/X11/rootfs", "/mnt/opt/X11/rootfs", "", MS_BIND, "");
+		MOUNT("/mnt/opt/storage/X11/rootfs", "/mnt/opt/X11/rootfs", "", MS_BIND, "");
 		set_progress(30);
 		progress_sleep();
 		// GUI root filesystem
 		mkpath("/mnt/opt/storage/gui_rootfs", 0755);
-		mount("/mnt/opt/storage/gui_rootfs", "/mnt/opt/gui_rootfs", "", MS_BIND, "");
+		MOUNT("/mnt/opt/storage/gui_rootfs", "/mnt/opt/gui_rootfs", "", MS_BIND, "");
 		// SSHd
 		mkpath("/mnt/opt/storage/ssh", 0755);
-		mount("/mnt/opt/storage/ssh", "/mnt/etc/ssh", "", MS_BIND, "");
+		MOUNT("/mnt/opt/storage/ssh", "/mnt/etc/ssh", "", MS_BIND, "");
 		write_file("/mnt/opt/storage/ssh/sshd_config", "");
 		write_file("/tmp/sshd_config", "PermitRootLogin yes\nSubsystem sftp internal-sftp\n# If sshfs doesn't work, first enable read-write support, then begin a connection with sshfs\n");
-		mount("/tmp/sshd_config", "/mnt/etc/ssh/sshd_config", "", MS_BIND, "");
+		MOUNT("/tmp/sshd_config", "/mnt/etc/ssh/sshd_config", "", MS_BIND, "");
 		set_progress(40);
 		progress_sleep();
 
@@ -494,8 +609,8 @@ int main() {
 		// Essential filesystems
 		mount_essential_filesystems();
 		// developer
-		if(root == true) {
-			mount("tmpfs", "/mnt/opt/developer", "tmpfs", 0, "size=128K");
+		if(root) {
+			MOUNT("tmpfs", "/mnt/opt/developer", "tmpfs", 0, "size=128K");
 		}
 		info("Mounted essential filesystems", INFO_OK);
 		set_progress(45);
@@ -503,36 +618,40 @@ int main() {
 
 		// Wi-Fi
 		// Firmware
-		if(file_exists("/opt/firmware.sqsh") == true) {
-			const char * arguments[] = { "/sbin/losetup", "/dev/loop4", "/opt/firmware.sqsh", NULL }; run_command("/sbin/losetup", arguments, true);
-			mount("/dev/loop4", "/mnt/lib/firmware", "squashfs", MS_NODEV | MS_NOSUID | MS_NOEXEC, "");
+		if(FILE_EXISTS("/opt/firmware.sqsh")) {
+			const char * const arguments[] = { "/sbin/losetup", "/dev/loop4", "/opt/firmware.sqsh", NULL };
+			run_command("/sbin/losetup", arguments, true);
+			MOUNT("/dev/loop4", "/mnt/lib/firmware", "squashfs", MS_NODEV | MS_NOSUID | MS_NOEXEC, "");
 		}
 		// resolv.conf
 		write_file("/tmp/resolv.conf", "");
-		mount("/tmp/resolv.conf", "/mnt/etc/resolv.conf", "", MS_BIND, "");
+		MOUNT("/tmp/resolv.conf", "/mnt/etc/resolv.conf", "", MS_BIND, "");
 		// DHCPcd
-		mount("tmpfs", "/mnt/var/db/dhcpcd", "tmpfs", MS_NODEV | MS_NOSUID | MS_NOEXEC, "size=512K");
+		MOUNT("tmpfs", "/mnt/var/db/dhcpcd", "tmpfs", MS_NODEV | MS_NOSUID | MS_NOEXEC, "size=512K");
 		write_file("/mnt/var/db/dhcpcd/duid", "");
 		write_file("/mnt/opt/storage/dhcpcd_duid", "");
-		mount("/mnt/opt/storage/dhcpcd_duid", "/mnt/var/db/dhcpcd/duid", "", MS_BIND, "");
+		MOUNT("/mnt/opt/storage/dhcpcd_duid", "/mnt/var/db/dhcpcd/duid", "", MS_BIND, "");
 
 		// Developer key
+		char * developer_key = NULL;
 		{
 			{
-				const char * arguments[] = { "/etc/init.d/developer-key", NULL }; run_command("/etc/init.d/developer-key", arguments, true);
+				const char * const arguments[] = { "/etc/init.d/developer-key", NULL };
+				run_command("/etc/init.d/developer-key", arguments, true);
 			}
 			developer_key = read_file("/mnt/opt/developer/key/valid-key", true);
 			// 'Developer mode' splash
-			if(strstr(developer_key, "true") && strstr(will_update, "true")) {
-				const char * arguments[] = { "/etc/init.d/inkbox-splash", "developer_splash", NULL }; run_command("/etc/init.d/inkbox-splash", arguments, false);
+			if(MATCH(developer_key, "true") && do_update) {
+				const char * const arguments[] = { "/etc/init.d/inkbox-splash", "developer_splash", NULL };
+				run_command("/etc/init.d/inkbox-splash", arguments, false);
 			}
 		}
 
 		// GUI root filesystem
 		{
 			// Validating digital signature
-			const char * arguments[] = { "/usr/bin/openssl", "dgst", "-sha256", "-verify", "/mnt/opt/key/public.pem", "-signature", "/mnt/opt/storage/gui_rootfs.isa.dgst", "/mnt/opt/storage/gui_rootfs.isa", NULL };
-			if(run_command("/usr/bin/openssl", arguments, true) != 0 && strstr(developer_key, "true") != 0) {
+			const char * const arguments[] = { "/usr/bin/openssl", "dgst", "-sha256", "-verify", "/mnt/opt/key/public.pem", "-signature", "/mnt/opt/storage/gui_rootfs.isa.dgst", "/mnt/opt/storage/gui_rootfs.isa", NULL };
+			if(run_command("/usr/bin/openssl", arguments, true) != 0 && NOT_MATCH(developer_key, "true")) {
 				info("GUI root filesystem's digital signature is invalid!", INFO_FATAL);
 				info("Aborting boot and powering off", INFO_FATAL);
 				kill_process("inkbox-splash", SIGTERM);
@@ -542,11 +661,13 @@ int main() {
 			else {
 				// Mounting GUI root filesystem
 				{
-					const char * arguments[] = { "/bin/busybox", "chroot", "/mnt", "/bin/squashfuse", "/opt/storage/gui_rootfs.isa", "/opt/gui_rootfs/read", NULL }; run_command("/bin/busybox", arguments, true);
+					const char * const args[] = { "/bin/busybox", "chroot", "/mnt", "/bin/squashfuse", "/opt/storage/gui_rootfs.isa", "/opt/gui_rootfs/read", NULL };
+					run_command("/bin/busybox", args, true);
 				}
 				// Setting up GUI root filesystem overlay
 				{
-					const char * arguments[] = { "/bin/busybox", "chroot", "/mnt", "/usr/local/bin/unionfs", "-o", "cow,nonempty", "/opt/gui_rootfs/write=RW:/opt/gui_rootfs/read=RO", "/kobo", NULL }; run_command("/bin/busybox", arguments, true);
+					const char * const args[] = { "/bin/busybox", "chroot", "/mnt", "/usr/local/bin/unionfs", "-o", "cow,nonempty", "/opt/gui_rootfs/write=RW:/opt/gui_rootfs/read=RO", "/kobo", NULL };
+					run_command("/bin/busybox", args, true);
 				}
 				write_file("/mnt/kobo/inkbox/remount", "true");
 			}
@@ -558,8 +679,9 @@ int main() {
 		set_progress(50);
 		progress_sleep();
 
-		if(strstr(x11_start, "true")) {
-			const char * arguments[] = { "/etc/init.d/startx", NULL }; run_command("/etc/init.d/startx", arguments, true);
+		if(with_x11) {
+			const char * const arguments[] = { "/etc/init.d/startx", NULL };
+			run_command("/etc/init.d/startx", arguments, true);
 		}
 		set_progress(90);
 		progress_sleep();
@@ -568,7 +690,8 @@ int main() {
 		{
 			// OpenRC sysinit
 			{
-				const char * arguments[] = { "/bin/busybox", "chroot", "/mnt", "/sbin/openrc", "sysinit", NULL }; run_command("/bin/busybox", arguments, true);
+				const char * const arguments[] = { "/bin/busybox", "chroot", "/mnt", "/sbin/openrc", "sysinit", NULL };
+				run_command("/bin/busybox", arguments, true);
 			}
 
 			set_progress(100);
@@ -577,16 +700,19 @@ int main() {
 
 			// Init ramdisk named pipe
 			{
-				const char * arguments[] = { "/etc/init.d/initrd-fifo", NULL }; run_command("/etc/init.d/initrd-fifo", arguments, true);
+				const char * const arguments[] = { "/etc/init.d/initrd-fifo", NULL };
+				run_command("/etc/init.d/initrd-fifo", arguments, true);
 			}
 
 			// OpenRC boot
 			{
-				const char * arguments[] = { "/bin/busybox", "chroot", "/mnt", "/sbin/openrc", "boot", NULL }; run_command("/bin/busybox", arguments, true);
+				const char * const arguments[] = { "/bin/busybox", "chroot", "/mnt", "/sbin/openrc", "boot", NULL };
+				run_command("/bin/busybox", arguments, true);
 			}
 			// OpenRC default
 			{
-				const char * arguments[] = { "/bin/busybox", "chroot", "/mnt", "/sbin/openrc", "default", NULL }; run_command("/bin/busybox", arguments, true);
+				const char * const arguments[] = { "/bin/busybox", "chroot", "/mnt", "/sbin/openrc", "default", NULL };
+				run_command("/bin/busybox", arguments, true);
 			}
 		}
 	}
@@ -594,15 +720,15 @@ int main() {
 		// Preparing Diagnostics chroot environment
 		// Mounting base Diagnostics root filesystem
 		{
-			const char * arguments[] = { "/etc/init.d/overlay-mount", "recovery", NULL };
-			int ret = run_command("/etc/init.d/overlay-mount", arguments, true);
+			const char * const arguments[] = { "/etc/init.d/overlay-mount", "recovery", NULL };
+			long int ret = run_command("/etc/init.d/overlay-mount", arguments, true);
 			if(ret != 0) {
 				exit(ret);
 			}
 			info("Mounted base recovery filesystem", INFO_OK);
 		}
 		// Mounting boot flags partition
-		mount("/dev/mmcblk0p1", "/mnt/boot", "ext4", 0, "");
+		MOUNT("/dev/mmcblk0p1", "/mnt/boot", "ext4", 0, "");
 		// Essential filesystems
 		mount_essential_filesystems();
 		info("Mounted essential filesystems", INFO_OK);
@@ -612,87 +738,113 @@ int main() {
 
 		// Launching Diagnostics subsysten
 		{
-			const char * arguments[] = { "/bin/busybox", "chroot", "/mnt", "/opt/bin/diagnostics_splash", NULL }; run_command("/bin/busybox", arguments, true);
+			const char * const arguments[] = { "/bin/busybox", "chroot", "/mnt", "/opt/bin/diagnostics_splash", NULL };
+			run_command("/bin/busybox", arguments, true);
 		}
 		{
-			const char * arguments[] = { "/bin/busybox", "chroot", "/mnt", "/opt/recovery/launch.sh", NULL }; run_command("/bin/busybox", arguments, true);
+			const char * const arguments[] = { "/bin/busybox", "chroot", "/mnt", "/opt/recovery/launch.sh", NULL };
+			run_command("/bin/busybox", arguments, true);
 		}
 	}
 
 	// Start getty in chroot
-	const char * arguments[] = { "/bin/busybox", "chroot", "/mnt", "/sbin/getty", "-L", tty, "115200", "linux", NULL }; run_command("/bin/busybox", arguments, true);
-	sleep(-1);
-}
+	const char * const arguments[] = { "/bin/busybox", "chroot", "/mnt", "/sbin/getty", "-L", tty, "115200", "linux", NULL };
+	run_command("/bin/busybox", arguments, true);
 
-// https://github.com/Kobo-InkBox/inkbox-power-daemon/blob/8296c4a1811e3921ff98e9980504c24d23435dac/src/functions.cpp#L415-L430
-int run_command(const char * path, const char * arguments[], bool wait) {
-	int status = -1;
-	int pid = 0;
-
-	status = posix_spawn(&pid, path, NULL, NULL, (char**)arguments, NULL);
-	if(status != 0) {
-		fprintf(stderr, "Error in spawning process %s\n", path);
-		return false;
+	while (true) {
+		sleep(-1U);
 	}
+}
 
-	if(wait == true) {
-		int exit_code = 0;
-		waitpid(pid, &exit_code, 0);
-		return exit_code;
+long int run_command(const char * path, const char * const arguments[], bool wait) {
+	pid_t pid = -1;
+
+#pragma GCC diagnostic   push
+#pragma GCC diagnostic   ignored "-Wunknown-pragmas"
+#pragma clang diagnostic ignored "-Wunknown-warning-option"
+#pragma GCC diagnostic   ignored "-Wdiscarded-qualifiers"
+#pragma GCC diagnostic   ignored "-Wincompatible-pointer-types"
+#pragma clang diagnostic ignored "-Wincompatible-pointer-types-discards-qualifiers"
+	int status = posix_spawn(&pid, path, NULL, NULL, arguments, NULL);
+#pragma GCC diagnostic pop
+	if (status != 0) {
+		fprintf(stderr, "Error in spawning process %s (%s)\n", path, strerror(status));
+		return -(EXIT_FAILURE);
+	}
+
+	if (wait) {
+		pid_t ret;
+		int wstatus;
+		do {
+			ret = waitpid(pid, &wstatus, 0);
+		} while (ret == -1 && errno == EINTR);
+		if (ret != pid) {
+			perror("waitpid");
+			return -(EXIT_FAILURE);
+		} else {
+			if (WIFEXITED(wstatus)) {
+				int exitcode = WEXITSTATUS(wstatus);
+				return exitcode;
+			} else if (WIFSIGNALED(wstatus)) {
+				int sigcode = WTERMSIG(wstatus);
+				psignal(sigcode, "child caught signal");
+				return EXIT_SUCCESS;
+			} else if (WIFSTOPPED(wstatus)) {
+				printf("child stopped by signal %d\n", WSTOPSIG(wstatus));
+				return EXIT_SUCCESS;
+			} else if (WIFCONTINUED(wstatus)) {
+				printf("child continued\n");
+				return EXIT_SUCCESS;
+			}
+		}
 	}
 
 	return pid;
 }
 
-// https://stackoverflow.com/a/230070/14164574
-bool file_exists(char * file_path) {
-	struct stat buffer;
-	return (stat(file_path, &buffer) == 0);
-}
-
 // https://stackoverflow.com/a/3747128/14164574
-char * read_file(char * file_path, bool strip_newline) {
+char * read_file(const char * file_path, bool strip_newline) {
 	// Ensure that specified file exists, then try to read it
-	if(access(file_path, F_OK) == 0) {
-		FILE * fp;
-		long lSize;
-		char * buffer;
-
-		fp = fopen(file_path , "rb");
+	if (access(file_path, F_OK) != 0) {
+		return NULL;
+	}
 
-		fseek(fp, 0L , SEEK_END);
-		// If requested, remove trailing newline
-		if(strip_newline == true) {
-			lSize = ftell(fp) - 1;
-		}
-		else {
-			lSize = ftell(fp);
-		}
-		rewind(fp);
+	FILE * fp = fopen(file_path , "rb");
+	if (!fp) {
+		return NULL;
+	}
 
-		// Allocate memory for entire content
-		buffer = calloc(1, lSize+1);
-		if(!buffer) fclose(fp);
+	fseek(fp, 0L, SEEK_END);
+	long bytes = ftell(fp);
+	rewind(fp);
 
-		// Copy the file into the buffer
-		if(1 != fread(buffer, lSize, 1, fp)) {
-			fclose(fp);
-		}
-		else {
-			fclose(fp);
-		}
+	// Allocate memory for entire content
+	char * buffer = NULL;
+	buffer = calloc(sizeof(*buffer), (size_t) bytes + 1U);
+	if (!buffer) {
+		goto cleanup;
+	}
 
-		// Return the buffer
-		return(buffer);
+	// Copy the file into the buffer
+	if (fread(buffer, sizeof(*buffer), (size_t) bytes, fp) < (size_t) bytes || ferror(fp) != 0) {
+		// Short read or error, meep!
 		free(buffer);
+		buffer = NULL;
+		goto cleanup;
 	}
-	else {
-		return("");
+
+	// If requested, remove trailing newline
+	if (strip_newline && bytes > 0 && buffer[bytes - 1] == '\n') {
+		buffer[bytes - 1] = '\0';
 	}
+
+cleanup:
+	fclose(fp);
+	return buffer; // May be NULL (indicates failure)
 }
 
 // https://stackoverflow.com/a/14576624/14164574
-bool write_file(char * file_path, char * content) {
+bool write_file(const char * file_path, const char * content) {
 	FILE *file = fopen(file_path, "wb");
 	if (!file) {
 		return false;
@@ -704,25 +856,23 @@ bool write_file(char * file_path, char * content) {
 }
 
 // https://stackoverflow.com/a/39191360/14164574
-bool copy_file(char * source_file, char * destination_file) {
-	FILE *fp_I;
-	FILE *fp_O;
-
-	fp_I = fopen(source_file, "rb");
+bool copy_file(const char * source_file, const char * destination_file) {
+	FILE * fp_I = fopen(source_file, "rb");
 	if(!fp_I) {
 		perror(source_file);
 		return false;
 	}
 
-	fp_O = fopen(destination_file, "wb");
+	FILE * fp_O = fopen(destination_file, "wb");
 	if(!fp_O) {
 		fclose(fp_I);
 		return false;
 	}
 
-	int c;
-	while((c = getc(fp_I)) != EOF) {
-		putc(c, fp_O);
+	char buffer[PIPE_BUF];
+	size_t len = 0U;
+	while((len = fread(buffer, sizeof(*buffer), PIPE_BUF, fp_I)) > 0) {
+		fwrite(buffer, sizeof(*buffer), len, fp_O);
 	}
 
 	fclose(fp_I);
@@ -732,7 +882,7 @@ bool copy_file(char * source_file, char * destination_file) {
 	return true;
 }
 
-bool mkpath(char * path, mode_t mode) {
+int mkpath(const char * path, mode_t mode) {
 	if(!path) {
 		errno = EINVAL;
 		return 1;
@@ -747,16 +897,29 @@ bool mkpath(char * path, mode_t mode) {
 }
 
 // https://github.com/Kobo-InkBox/inkbox-power-daemon/blob/8296c4a1811e3921ff98e9980504c24d23435dac/src/wifi.cpp#L181-L197
-int load_module(char * module_path, char * params) {
-	size_t image_size;
-	struct stat st;
-	void * image;
-
+int load_module(const char * module_path, const char * params) {
 	int fd = open(module_path, O_RDONLY);
-	fstat(fd, &st);
-	image_size = st.st_size;
-	image = malloc(image_size);
-	read(fd, image, image_size);
+	if (fd == -1) {
+		perror("open");
+		return EXIT_FAILURE;
+	}
+	struct stat st;
+	if (fstat(fd, &st) == -1) {
+		perror("fstat");
+		return EXIT_FAILURE;
+	}
+	size_t image_size = (size_t) st.st_size;
+	void * image = malloc(image_size);
+	if (!image) {
+		perror("malloc");
+		close(fd);
+		return EXIT_FAILURE;
+	}
+	if (read(fd, image, image_size) != (ssize_t) image_size) {
+		fprintf(stderr, "load_module %s: failed/short read\n", module_path);
+		close(fd);
+		return EXIT_FAILURE;
+	}
 	close(fd);
 
 	int rc = initModule(image, image_size, params);
@@ -770,66 +933,73 @@ int load_module(char * module_path, char * params) {
 }
 
 // https://stackoverflow.com/a/49334887/14164574
-int set_if_flags(char * if_name, short flags) {
-	struct ifreq ifr;
+int set_if_flags(const char * if_name, short flags) {
 	int res = 0;
 
-	ifr.ifr_flags = flags;
-	strncpy(ifr.ifr_name, if_name, IFNAMSIZ);
-
-	if((skfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
-		printf("Socket error %s\n", strerror(errno));
+	int fd = -1;
+	if((fd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
+		perror("socket");
 		res = 1;
-		goto out;
+		goto cleanup;
 	}
 
-	res = ioctl(skfd, SIOCSIFFLAGS, &ifr);
+	struct ifreq ifr;
+	ifr.ifr_flags = flags;
+	strncpy(ifr.ifr_name, if_name, IFNAMSIZ);
+
+	res = ioctl(fd, SIOCSIFFLAGS, &ifr);
 	if (res < 0) {
-		printf("Interface '%s': Error: SIOCSIFFLAGS failed: %s\n", if_name, strerror(errno));
+		fprintf(stderr, "Interface '%s': Error: SIOCSIFFLAGS failed: %s\n", if_name, strerror(errno));
 	}
 	else {
-		printf("Interface '%s': flags set to %04X.\n", if_name, flags);
+		printf("Interface '%s': flags set to %04X.\n", if_name, (unsigned int) flags);
 	}
 
-	out:
+cleanup:
+	close(fd);
 	return res;
 }
 
-int set_if_up(char * if_name) {
+int set_if_up(const char * if_name) {
     return set_if_flags(if_name, IFF_UP);
 }
 
 // https://www.includehelp.com/c-programs/set-ip-address-in-linux.aspx
-int set_if_ip_address(char * if_name, char * ip_address) {
-	int fd;
-	struct ifreq ifr;
-	struct sockaddr_in * addr;
+int set_if_ip_address(const char * if_name, const char * ip_address) {
+	int res = 0;
 
 	// AF_INET - to define network interface IPv4
 	// Creating soket for it
-	fd = socket(AF_INET, SOCK_DGRAM, 0);
+	int fd = -1;
+	if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
+		perror("socket");
+		res = 1;
+		goto cleanup;
+	}
 
+	struct ifreq ifr;
 	// AF_INET - to define IPv4 Address type
 	ifr.ifr_addr.sa_family = AF_INET;
 
 	// eth0 - define the ifr_name - port name
-	memcpy(ifr.ifr_name, if_name, IFNAMSIZ - 1);
+	strncpy(ifr.ifr_name, if_name, IFNAMSIZ);
 
 	// Defining sockaddr_in
+	struct sockaddr_in * addr;
 	addr = (struct sockaddr_in*)&ifr.ifr_addr;
 
 	// Convert IP address in correct format to write
 	inet_pton(AF_INET, ip_address, &addr->sin_addr);
 
 	// Setting IP Address using ioctl
-	int res = ioctl(fd, SIOCSIFADDR, &ifr);
-	// Closing file descriptor
-	close(fd);
+	res = ioctl(fd, SIOCSIFADDR, &ifr);
 
+cleanup:
+	close(fd);
 	return res;
 }
 
-int info(char * message, int mode) {
+int info(const char * message, int mode) {
 	/*
 	 * Modes:
 	 * - 0: Normal logging (green) - INFO_OK
@@ -851,34 +1021,37 @@ int info(char * message, int mode) {
 	return 0;
 }
 
-void launch_dfl() {
+void launch_dfl(void) {
 	// Loading USB Mass Storage (USBMS) modules
 	mkpath("/modules", 0755);
 	{
-		const char * arguments[] = { "/sbin/losetup", "/dev/loop0", "/opt/modules.sqsh", NULL }; run_command("/sbin/losetup", arguments, true);
-		mount("/dev/loop0", "/modules", "squashfs", 0, "");
+		const char * const arguments[] = { "/sbin/losetup", "/dev/loop0", "/opt/modules.sqsh", NULL };
+		run_command("/sbin/losetup", arguments, true);
+		MOUNT("/dev/loop0", "/modules", "squashfs", 0, "");
 	}
 
-	if(strstr(device, "n705") || strstr(device, "n905b") || strstr(device, "n905c") || strstr(device, "n613")) {
+	if(MATCH(device, "n705") || MATCH(device, "n905b") || MATCH(device, "n905c") || MATCH(device, "n613")) {
 		load_module("/modules/arcotg_udc.ko", "");
 	}
-	if(strstr(device, "n306") || strstr(device, "n873")) {
+	if(MATCH(device, "n306") || MATCH(device, "n873")) {
 		load_module("/modules/fs/configfs/configfs.ko", "");
 		load_module("/modules/drivers/usb/gadget/libcomposite.ko", "");
 		load_module("/modules/drivers/usb/gadget/function/usb_f_mass_storage.ko", "");
 	}
-	if(!strstr(device, "emu")) {
+	if(NOT_MATCH(device, "emu")) {
 		load_module("/modules/g_mass_storage.ko", "file=/dev/mmcblk0 removable=y stall=0");
 	}
 
 	// Unmount modules
 	{
 		umount("/modules");
-		const char * arguments[] = { "/sbin/losetup", "/dev/loop0", "/opt/root.sqsh", NULL }; run_command("/sbin/losetup", arguments, true);
+		const char * const arguments[] = { "/sbin/losetup", "/dev/loop0", "/opt/root.sqsh", NULL };
+		run_command("/sbin/losetup", arguments, true);
 	}
 
 	// Splash time
-	const char * arguments[] = { "/etc/init.d/inkbox-splash", "dfl", NULL }; run_command("/etc/init.d/inkbox-splash", arguments, true);
+	const char * const arguments[] = { "/etc/init.d/inkbox-splash", "dfl", NULL };
+	run_command("/etc/init.d/inkbox-splash", arguments, true);
 	while(true) {
 		info("This device is in DFL mode. Please reset it to resume normal operation.", INFO_OK);
 		sleep(30);
@@ -887,21 +1060,24 @@ void launch_dfl() {
 
 void setup_usb_debug(bool boot) {
 	mkpath("/dev/pts", 0755);
-	mount("devpts", "/dev/pts", "devpts", 0, "");
+	MOUNT("devpts", "/dev/pts", "devpts", 0, "");
 	{
 		// Telnet server
-		const char * arguments[] = { "/bin/busybox", "telnetd", NULL }; run_command("/bin/busybox", arguments, false);
+		const char * const arguments[] = { "/bin/busybox", "telnetd", NULL };
+		run_command("/bin/busybox", arguments, false);
 	}
 	{
 		// FTP server
-		const char * arguments[] = { "/bin/busybox", "tcpsvd", "-vE", "0.0.0.0", "21", "ftpd", "-A", "-w", "/", NULL }; run_command("/bin/busybox", arguments, false);
+		const char * const arguments[] = { "/bin/busybox", "tcpsvd", "-vE", "0.0.0.0", "21", "ftpd", "-A", "-w", "/", NULL };
+		run_command("/bin/busybox", arguments, false);
 	}
 
-	if(boot == true) {
+	if(boot) {
 		// Set up USB networking interface
 		setup_usbnet();
 		// Splash time
-		const char * arguments[] = { "/etc/init.d/inkbox-splash", "usb_debug", NULL }; run_command("/etc/init.d/inkbox-splash", arguments, true);
+		const char * const arguments[] = { "/etc/init.d/inkbox-splash", "usb_debug", NULL };
+		run_command("/etc/init.d/inkbox-splash", arguments, true);
 		while(true) {
 			info("This device is in boot-time USB debug mode. Please reset or reboot it to resume normal operation.", INFO_OK);
 			sleep(30);
@@ -909,37 +1085,38 @@ void setup_usb_debug(bool boot) {
 	}
 }
 
-void setup_usbnet() {
+void setup_usbnet(void) {
 	// Load modules
 	mkpath("/modules", 0755);
 	{
-		const char * arguments[] = { "/sbin/losetup", "/dev/loop0", "/opt/modules.sqsh", NULL }; run_command("/sbin/losetup", arguments, true);
-		mount("/dev/loop0", "/modules", "squashfs", 0, "");
+		const char * const arguments[] = { "/sbin/losetup", "/dev/loop0", "/opt/modules.sqsh", NULL };
+		run_command("/sbin/losetup", arguments, true);
+		MOUNT("/dev/loop0", "/modules", "squashfs", 0, "");
 	}
 
-	if(strstr(device, "n705") || strstr(device, "n905b") || strstr(device, "n905c") || strstr(device, "n613")) {
+	if(MATCH(device, "n705") || MATCH(device, "n905b") || MATCH(device, "n905c") || MATCH(device, "n613")) {
 		load_module("/modules/arcotg_udc.ko", "");
 	}
-	if(strstr(device, "n705") || strstr(device, "n905b") || strstr(device, "n905c") || strstr(device, "n613") || strstr(device, "n236") || strstr(device, "n437")) {
+	if(MATCH(device, "n705") || MATCH(device, "n905b") || MATCH(device, "n905c") || MATCH(device, "n613") || MATCH(device, "n236") || MATCH(device, "n437")) {
 		load_module("/modules/g_ether.ko", "");
 	}
-	else if(strstr(device, "n306") || strstr(device, "n873") || strstr(device, "bpi")) {
+	else if(MATCH(device, "n306") || MATCH(device, "n873") || MATCH(device, "bpi")) {
 		load_module("/modules/fs/configfs/configfs.ko", "");
 		load_module("/modules/drivers/usb/gadget/libcomposite.ko", "");
 		load_module("/modules/drivers/usb/gadget/function/u_ether.ko", "");
 		load_module("/modules/drivers/usb/gadget/function/usb_f_ecm.ko", "");
-		if(file_exists("/modules/drivers/usb/gadget/function/usb_f_eem.ko")) {
+		if(FILE_EXISTS("/modules/drivers/usb/gadget/function/usb_f_eem.ko")) {
 			load_module("/modules/drivers/usb/gadget/function/usb_f_eem.ko", "");
 		}
 		load_module("/modules/drivers/usb/gadget/function/usb_f_ecm_subset.ko", "");
 		load_module("/modules/drivers/usb/gadget/function/usb_f_rndis.ko", "");
 		load_module("/modules/drivers/usb/gadget/legacy/g_ether.ko", "");
 	}
-	else if(strstr(device, "kt")) {
+	else if(MATCH(device, "kt")) {
 		load_module("/modules/2.6.35-inkbox/kernel/drivers/usb/gadget/arcotg_udc.ko", "");
 		load_module("/modules/2.6.35-inkbox/kernel/drivers/usb/gadget/g_ether.ko", "");
 	}
-	else if(strstr(device, "emu")) {
+	else if(MATCH(device, "emu")) {
 		;
 	}
 	else {
@@ -949,13 +1126,14 @@ void setup_usbnet() {
 	// Unmount modules
 	{
 		umount("/modules");
-		const char * arguments[] = { "/sbin/losetup", "-d", "/dev/loop0", NULL }; run_command("/sbin/losetup", arguments, true);
+		const char * const arguments[] = { "/sbin/losetup", "-d", "/dev/loop0", NULL };
+		run_command("/sbin/losetup", arguments, true);
 	}
 
 	// Setting up network interface
 	set_if_up("usb0");
 	// Checking for custom IP address
-	if(usbnet_ip != NULL && usbnet_ip[0] != '\0') {
+	if(usbnet_ip && *usbnet_ip) {
 		if(set_if_ip_address("usb0", usbnet_ip) != 0) {
 			set_if_ip_address("usb0", "192.168.2.2");
 		}
@@ -965,59 +1143,63 @@ void setup_usbnet() {
 	}
 }
 
-void setup_shell() {
+void setup_shell(void) {
 	// Starting getty in init ramdisk root
-	const char * arguments[] = { "/sbin/getty", "-L", tty, "115200", "linux", NULL }; run_command("/bin/busybox", arguments, true);
-	sleep(-1);
+	const char * const arguments[] = { "/sbin/getty", "-L", tty, "115200", "linux", NULL };
+	run_command("/bin/busybox", arguments, true);
+
+	while (true) {
+		sleep(-1U);
+	}
 }
 
-void read_sector(char * device_node, unsigned long sector, int sector_size, unsigned long bytes_to_read) {
+void read_sector(char * buffer, size_t len, const char * device_node, off_t sector, size_t sector_size) {
 	int fd = open(device_node, O_RDONLY);
-	sector = sector * sector_size;
+	sector = sector * (off_t) sector_size;
 	lseek(fd, sector, SEEK_SET);
-	read(fd, &sector_content, bytes_to_read);
+	read(fd, buffer, len);
 	close(fd);
 }
 
 void show_alert_splash(int error_code, bool flag) {
 	// Converting error code to char
-	char code[10];
+	char code[10] = { 0 };
 	sprintf(code, "%d", error_code);
 
 	// Showing alert splash
-	if(flag == true) {
-		const char * arguments[] = { "/etc/init.d/inkbox-splash", "alert_splash", code, "flag", NULL };
+	if(flag) {
+		const char * const arguments[] = { "/etc/init.d/inkbox-splash", "alert_splash", code, "flag", NULL };
 		run_command("/etc/init.d/inkbox-splash", arguments, true);
 	}
 	else {
-		const char * arguments[] = { "/etc/init.d/inkbox-splash", "alert_splash", code, NULL };
+		const char * const arguments[] = { "/etc/init.d/inkbox-splash", "alert_splash", code, NULL };
 		run_command("/etc/init.d/inkbox-splash", arguments, true);
 	}
 }
 
 void set_progress(int progress_value) {
 	// Converting progress value to char
-	char progress[3];
+	char progress[5] = { 0 };
 	sprintf(progress, "%d\n", progress_value);
 
 	// Sending progress value to named pipe
 	write_file(PROGRESS_BAR_FIFO_PATH, progress);
 }
 
-void progress_sleep() {
+void progress_sleep(void) {
 	usleep(500);
 }
 
 // https://github.com/Kobo-InkBox/inkbox-power-daemon/blob/80eb0500c3f360f78563cc380617a56c5b62c01f/src/appsFreeze.cpp#L21-L44
-int get_pid_by_name(char * name) {
+int get_pid_by_name(const char * name) {
 	struct dirent * entry = NULL;
 	DIR * dp = NULL;
 
-	char proc[] = "/proc";
+	const char proc[] = "/proc";
 	dp = opendir(proc);
 	while((entry = readdir(dp))) {
 		// cmdline is more accurate, sometimes status may be buggy
-		char cmdline_file[1024];
+		char cmdline_file[1024] = { 0 };
 		sprintf(cmdline_file, "%s%s/cmdline", proc, entry->d_name);
 		char * cmdline = read_file(cmdline_file, true);
 		// https://stackoverflow.com/questions/2340281/check-if-a-string-contains-a-string-in-c
@@ -1025,8 +1207,10 @@ int get_pid_by_name(char * name) {
 			// After closing directory, it's impossible to call entry->d_name
 			int return_pid = atoi(entry->d_name);
 			closedir(dp);
+			free(cmdline);
 			return return_pid;
 		}
+		free(cmdline);
 	}
 	// If we get here, we haven't found any PID
 	closedir(dp);
@@ -1034,40 +1218,43 @@ int get_pid_by_name(char * name) {
 }
 
 // https://github.com/Kobo-InkBox/inkbox-power-daemon/blob/80eb0500c3f360f78563cc380617a56c5b62c01f/src/appsFreeze.cpp#L108-L114
-void kill_process(char * name, int signal) {
+void kill_process(const char * name, int signal) {
 	int pid = get_pid_by_name(name);
 	if(pid != -1) {
 		kill(pid, signal);
 	}
 }
 
-void mount_essential_filesystems() {
+void mount_essential_filesystems(void) {
 	// proc
-	mount("/proc", "/mnt/proc", "", MS_BIND | MS_REC, "");
+	MOUNT("/proc", "/mnt/proc", "", MS_BIND | MS_REC, "");
 	// sys
-	mount("/sys", "/mnt/sys", "", MS_BIND | MS_REC, "");
+	MOUNT("/sys", "/mnt/sys", "", MS_BIND | MS_REC, "");
 	// dev
-	mount("/dev", "/mnt/dev", "", MS_BIND | MS_REC, "");
+	MOUNT("/dev", "/mnt/dev", "", MS_BIND | MS_REC, "");
 	// tmp
-	mount("tmpfs", "/mnt/tmp", "tmpfs", 0, "size=16M");
+	MOUNT("tmpfs", "/mnt/tmp", "tmpfs", 0, "size=16M");
 	// log
-	mount("tmpfs", "/mnt/var/log", "tmpfs", 0, "size=8M");
+	MOUNT("tmpfs", "/mnt/var/log", "tmpfs", 0, "size=8M");
 }
 
-void mount_squashfs_archives() {
+void mount_squashfs_archives(void) {
 	// Userspace 'root' flag
-	if(root == true) {
-		const char * arguments[] = { "/sbin/losetup", "/dev/loop7", "/opt/root.sqsh", NULL }; run_command("/sbin/losetup", arguments, true);
-		mount("/dev/loop7", "/mnt/opt/root", "squashfs", MS_NODEV | MS_NOSUID | MS_NOEXEC, "");
+	if(root) {
+		const char * const arguments[] = { "/sbin/losetup", "/dev/loop7", "/opt/root.sqsh", NULL };
+		run_command("/sbin/losetup", arguments, true);
+		MOUNT("/dev/loop7", "/mnt/opt/root", "squashfs", MS_NODEV | MS_NOSUID | MS_NOEXEC, "");
 	}
 	// Public key
 	{
-		const char * arguments[] = { "/sbin/losetup", "/dev/loop6", "/opt/key.sqsh", NULL }; run_command("/sbin/losetup", arguments, true);
-		mount("/dev/loop6", "/mnt/opt/key", "squashfs", MS_NODEV | MS_NOSUID | MS_NOEXEC, "");
+		const char * const arguments[] = { "/sbin/losetup", "/dev/loop6", "/opt/key.sqsh", NULL };
+		run_command("/sbin/losetup", arguments, true);
+		MOUNT("/dev/loop6", "/mnt/opt/key", "squashfs", MS_NODEV | MS_NOSUID | MS_NOEXEC, "");
 	}
 	// Modules
 	{
-		const char * arguments[] = { "/sbin/losetup", "/dev/loop5", "/opt/modules.sqsh", NULL }; run_command("/sbin/losetup", arguments, true);
-		mount("/dev/loop5", "/mnt/lib/modules", "squashfs", MS_NODEV | MS_NOSUID | MS_NOEXEC, "");
+		const char * const arguments[] = { "/sbin/losetup", "/dev/loop5", "/opt/modules.sqsh", NULL };
+		run_command("/sbin/losetup", arguments, true);
+		MOUNT("/dev/loop5", "/mnt/lib/modules", "squashfs", MS_NODEV | MS_NOSUID | MS_NOEXEC, "");
 	}
 }
diff --git a/init.h b/init.h
index f16e640..ed81c07 100644
--- a/init.h
+++ b/init.h
@@ -1,10 +1,16 @@
 #ifndef INIT_H
 #define INIT_H
 
+// GNUisms welcome!
+#define _GNU_SOURCE
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <stdbool.h>
+#include <alloca.h>
+#include <signal.h>
+#include <poll.h>
 #include <string.h>
 #include <fcntl.h>
 #include <assert.h>
@@ -16,7 +22,7 @@
 #include <sys/syscall.h>
 #include <sys/ioctl.h>
 #include <sys/utsname.h>
-#include <linux/module.h>
+//#include <linux/module.h>
 #include <linux/input.h>
 #include <net/if.h>
 #include <netinet/in.h>
@@ -32,7 +38,7 @@
 #define INFO_FATAL 2
 #define ROOT_FLAG_SECTOR 79872
 #define ROOT_FLAG_SECTOR_KT 98304
-#define ROOT_FLAG_SIZE 6
+#define ROOT_FLAG_SIZE 6U
 #define BUTTON_INPUT_DEVICE "/dev/input/event0"
 #define BOOT_STANDARD 0
 #define BOOT_DIAGNOSTICS 1
@@ -40,57 +46,45 @@
 #define PROGRESS_BAR_FIFO_PATH "/run/progress_bar_fifo"
 
 // Variables
-char * device;
-bool root_mmc = false;
-bool root_initrd = false;
-bool root = false;
-bool power_button_pressed = false;
-bool other_button_pressed = false;
-int boot_mode = BOOT_STANDARD;
-static int skfd = -1; // AF_INET socket for ioctl() calls
-char * kernel_version = NULL;
-char * kernel_build_id;
-char * kernel_git_commit;
-char * display_debug;
-char * dont_boot;
-char * encrypt_lock;
-char * dfl;
-char * boot_usb_debug;
-char * diags_boot;
+char * device = NULL;
+char tty[8] = { 0 };
 char * usbnet_ip;
-char * initrd_debug;
-char sector_content[ROOT_FLAG_SIZE];
-char * will_update;
-int update_splash_pid;
-char * mount_rw;
-char * login_shell;
-char * developer_key;
-char * x11_start;
-char * tty;
+bool root = false;
+
+// Macros
+#define MATCH(s1, s2) (s1 && strcmp(s1, s2) == 0)
+#define NOT_MATCH(s1, s2) (s1 && strcmp(s1, s2) != 0)
+#define FILE_EXISTS(path) access(path, F_OK) == 0
+#define MOUNT(s, t, f, m, d) \
+({ \
+        if (mount(s, t, f, m, d) != 0) { \
+                perror("Failed to mount" t); \
+                exit(EXIT_FAILURE); \
+        } \
+})
 
 // Functions
-int run_command(const char * path, const char * arguments[], bool wait);
-bool file_exists(char * file_path);
-char * read_file(char * file_path, bool strip_newline);
-bool write_file(char * file_path, char * content);
-bool copy_file(char * source_file, char * destination_file);
-bool mkpath(char * path, mode_t mode);
-int load_module(char * module_path, char * params);
-int set_if_flags(char * if_name, short flags);
-int set_if_up(char * if_name);
-int set_if_ip_address(char * if_name, char * ip_address);
-int info(char * message, int mode);
-void launch_dfl();
+long int run_command(const char * path, const char * const arguments[], bool wait);
+char * read_file(const char * file_path, bool strip_newline);
+bool write_file(const char * file_path, const char * content);
+bool copy_file(const char * source_file, const char * destination_file);
+int mkpath(const char * path, mode_t mode);
+int load_module(const char * module_path, const char * params);
+int set_if_flags(const char * if_name, short flags);
+int set_if_up(const char * if_name);
+int set_if_ip_address(const char * if_name, const char * ip_address);
+int info(const char * message, int mode);
+void launch_dfl(void);
 void setup_usb_debug(bool boot);
-void setup_usbnet();
-void setup_shell();
-void read_sector(char * device_node, unsigned long sector, int sector_size, unsigned long bytes_to_read);
+void setup_usbnet(void);
+void setup_shell(void);
+void read_sector(char * buff, size_t len, const char * device_node, off_t sector, size_t sector_size);
 void show_alert_splash(int error_code, bool flag);
 void set_progress(int progress_value);
-void progress_sleep();
-int get_pid_by_name(char * name);
-void kill_process(char * name, int signal);
-void mount_essential_filesystems();
-void mount_squashfs_archives();
+void progress_sleep(void);
+int get_pid_by_name(const char * name);
+void kill_process(const char * name, int signal);
+void mount_essential_filesystems(void);
+void mount_squashfs_archives(void);
 
 #endif // INIT_H
