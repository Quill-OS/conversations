From 570dfe796f951055e019d23bc5de8ed3e46db55c Mon Sep 17 00:00:00 2001
From: Andreas Kemnade <andreas@kemnade.info>
Date: Sat, 12 Feb 2022 19:22:07 +0100
Subject: [PATCH] tce/clock diff towards clara

---
 .../video/fbdev/mxc/mxc_epdc_fake_s1d13522.c  | 103 +-
 drivers/video/fbdev/mxc/mxc_epdc_v2_fb.c      | 966 +++---------------
 2 files changed, 180 insertions(+), 889 deletions(-)

diff --git a/drivers/video/fbdev/mxc/mxc_epdc_fake_s1d13522.c b/drivers/video/fbdev/mxc/mxc_epdc_fake_s1d13522.c
index 9efee8da..b5f19074 100644
--- a/drivers/video/fbdev/mxc/mxc_epdc_fake_s1d13522.c
+++ b/drivers/video/fbdev/mxc/mxc_epdc_fake_s1d13522.c
@@ -158,9 +158,6 @@ static ssize_t xwi_write(struct device *dev, struct device_attribute *attr,const
 static ssize_t dither_enable_read(struct device *dev, struct device_attribute *attr,char *buf);
 static ssize_t dither_enable_write(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
 #endif //]DITHER_ENABLE
-static ssize_t tce_state_read(struct device *dev, struct device_attribute *attr,char *buf);
-static ssize_t tce_state_write(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
-
 
 #ifdef SYSFS_MODE_VER//[
 static DEVICE_ATTR(waveform_mode_ver, S_IWUSR | S_IRUSR|S_IROTH|S_IRGRP, waveform_mode_ver_read, waveform_mode_ver_write);
@@ -188,7 +185,6 @@ static DEVICE_ATTR(dbg, S_IWUSR | S_IRUSR|S_IROTH|S_IRGRP, dbg_read, dbg_write);
 static DEVICE_ATTR(dither_enable, S_IWUSR | S_IRUSR|S_IROTH|S_IRGRP, dither_enable_read, dither_enable_write);
 #endif //]DITHER_ENABLE
 
-static DEVICE_ATTR(tce_state, S_IWUSR|S_IRUSR|S_IROTH|S_IRGRP, tce_state_read, tce_state_write);
 
 
 #ifdef TPS65185_ENABLED//[
@@ -409,47 +405,46 @@ static ssize_t vcom_write(struct device *dev, struct device_attribute *attr,
 	//printk("%s():user input %dmV\n",__FUNCTION__,iVCOM_mV);
 
 	if(iVCOM_mV<0) {
-#ifdef FP9928_ENABLED//[
-		if(g_fp9928)
+		if(8==gptHWCFG->m_val.bDisplayCtrl || 12==gptHWCFG->m_val.bDisplayCtrl ||
+				13==gptHWCFG->m_val.bDisplayCtrl || 18==gptHWCFG->m_val.bDisplayCtrl) 
 		{
-			iChk = fp9928_set_vcom(g_fp9928,iVCOM_mV,0);
+#ifdef FP9928_ENABLED//[
+			struct fp9928 *fp9928 = _get_fp9928();	
+			iChk = fp9928_set_vcom(fp9928,iVCOM_mV,0);
 			if(iChk<0) {
 				printk(KERN_ERR"FP9928 VCOM %dmV write failed !\n",iVCOM_mV);
 			}
-		}
-		else
 #endif //]FP9928_ENABLED
-#ifdef TPS65185_ENABLED//[
-		if(g_tps6518x) 
+		}
+		else if(6==gptHWCFG->m_val.bDisplayCtrl||7==gptHWCFG->m_val.bDisplayCtrl||
+				11==gptHWCFG->m_val.bDisplayCtrl||15==gptHWCFG->m_val.bDisplayCtrl||
+				16==gptHWCFG->m_val.bDisplayCtrl) 
 		{
-			iChk = tps6518x_set_vcom(g_tps6518x,iVCOM_mV,0);
+#ifdef TPS65185_ENABLED//[
+			struct tps6518x *tps6518x = _get_tps6518x();
+
+			iChk = tps6518x_set_vcom(tps6518x,iVCOM_mV,0);
 			//iChk = tps65185_vcom_set(iVCOM_mV,0);
 			if(iChk<0) {
 				printk(KERN_ERR"TPS65185 VCOM %dmV write failed !\n",iVCOM_mV);
 			}
-		}
-		else
 #endif //]TPS65185_ENABLED
-#ifdef SY7636_ENABLED //[
-		if(g_sy7636)
+		}
+		else if(19==gptHWCFG->m_val.bDisplayCtrl||20==gptHWCFG->m_val.bDisplayCtrl||
+					21==gptHWCFG->m_val.bDisplayCtrl||22==gptHWCFG->m_val.bDisplayCtrl)
 		{
+#ifdef SY7636_ENABLED //[
 			// 
-			iChk = sy7636_set_vcom(g_sy7636,iVCOM_mV,0);
-			if(iChk<0) {
+			struct sy7636 *sy7636 = _get_sy7636();	
+			iChk = sy7636_set_vcom(sy7636,iVCOM_mV,0);
+			if(iChk>=0) {
 				printk(KERN_ERR"SY7636 VCOM %dmV write failed !\n",iVCOM_mV);
 			}
-		}
-		else 
 #endif //]SY7636_ENABLED
-		{
-			printk(KERN_ERR"%s():PMIC not avalible !\n",__FUNCTION__);
+		}
+		else {
 		}
 	}
-	else {
-		printk(KERN_ERR"%s():vcom set value should<0 (%dmV)\n",
-				__FUNCTION__,iVCOM_mV);
-	}
-
 	return strlen(buf);
 }
 
@@ -460,40 +455,13 @@ static ssize_t dbg_read(struct device *dev, struct device_attribute *attr,char *
 	sprintf (buf,"%d\n",g_fb_data->verbose_lvl);
 	return strlen(buf);
 }
+
 static void ntx_epdc_pmic_exception(int iEvt);
-static void epdc_recovery(struct mxc_epdc_fb_data *fb_data);
 static ssize_t dbg_write(struct device *dev, struct device_attribute *attr,
 		       const char *buf, size_t count)
 {
-	//strcpy(gcFB_snapshot_pathA,buf);
-	int iCnt=0;
-	char *pc=buf;
-
-	if(!pc) {
-		dev_err(dev,"%s() : parameter error !!",__FUNCTION__);
-		return 0;
-	}
-
-	while(*pc!='\0' && *pc!='\x0a' && *pc!='\x0d') 
-	{
-		if (*pc < '0' || *pc > '9') {
-			// special command .
-			//dev_info(dev,"invalid char=%c\n",*pc);
-			dev_info(dev,"debug command mode : \"%s\"\n",buf);
-			if(0==strcmp(buf,"epdc-reinit")) {
-				epdc_recovery(g_fb_data);
-			}
-			return strlen(buf);
-		}
-		pc++;
-
-		if(++iCnt>256) {
-			dev_err(dev,"parameter length cannot > 256\n",buf);
-			return 256;
-		}
-	}
-
 	sscanf(buf,"%d\n",&g_fb_data->verbose_lvl);
+	//strcpy(gcFB_snapshot_pathA,buf);
 	return strlen(buf);
 }
 #endif //]SYSFS_DBG
@@ -698,28 +666,6 @@ static ssize_t waveform_mode_write(struct device *dev, struct device_attribute *
 
 	return count;
 }
-static ssize_t tce_state_read(struct device *dev, struct device_attribute *attr,char *buf)
-{
-	switch (giTCE_State) {
-	case TCE_STATE_NORMAL:
-		sprintf (buf,"%s\n","normal");
-		break;
-	case TCE_STATE_CRITICAL:
-		sprintf (buf,"%s\n","critical");
-		break;
-	default:
-		sprintf (buf,"%s\n","unkown");
-		break;
-	}
-	return strlen(buf);
-}
-
-static ssize_t tce_state_write(struct device *dev, struct device_attribute *attr,
-		       const char *buf, size_t count)
-{
-	return strlen(buf);
-}
-
 
 static const struct attribute *sysfs_epdc_attrs[] = {
 #ifdef SYSFS_MODE_VER//[
@@ -749,7 +695,6 @@ static const struct attribute *sysfs_epdc_attrs[] = {
 #ifdef DITHER_ENABLE//[
 	&dev_attr_dither_enable.attr,
 #endif //]DITHER_ENABLE
-	&dev_attr_tce_state.attr,
 	NULL,
 };
 
diff --git a/drivers/video/fbdev/mxc/mxc_epdc_v2_fb.c b/drivers/video/fbdev/mxc/mxc_epdc_v2_fb.c
index 4c444c8d..4eae203e 100644
--- a/drivers/video/fbdev/mxc/mxc_epdc_v2_fb.c
+++ b/drivers/video/fbdev/mxc/mxc_epdc_v2_fb.c
@@ -81,7 +81,7 @@
 
 #define QOS_ENABLE		1
 //#define QOS_MX6SL			1
-#define QOS_MX6SLL		1
+//#define QOS_MX6SLL		1
 #define QOS_MX6ULL		1
 
 #ifdef QOS_MX6SL//[
@@ -107,37 +107,10 @@
 		printk(fmt,##args);\
 	}
 
-
-#define DROP_OLD_COLLISION		1
-
+//#define ENABLE_EPDC_REUPDATE_WORK	1
 #define ADJ_COLLISION_REGION_PATCH		1
 #define DITHER_GC16_COLLISION_PATCH		1
 
-#define TCE_UNDERRUN_PREVENT_PATCH	2
-#define TCE_UNDERRUN_PREVENT_PIXCLK	100000000
-#define TCE_UNDERRUN_PREVENT_X_RES	1920
-#define TCE_UNDERRUN_PREVENT_Y_RES	1440
-				/*
-				 * 1 : sleep a while after collision .
-				 * 2 : postpone the submit work .
-				 *
-				 */
-
-// TCE_UNDERRUN_RECOVERY 
-// 	1: recovery epdc .
-//	2: re-sending full update to fix dirty page .
-#define TCE_UNDERRUN_RECOVERY								2
-#define TCE_UNDERRUN_RECOVERY_UPDATE_DELAYMS						1000
-
-#define TCE_UNDERRUN_RECOVER_MARKERNO			0
-
-//#define TCE_UNDERRUN_PREVENT_WORKFUNC				1
-#define TCE_UNDERRUN_PREVENT_WORKFUNC_BUSYMS				50
-#define TCE_UNDERRUN_PREVENT_WORKFUNC_FREEMS				1
-#define TCE_UNDERRUN_PREVENT_WORKFUNC_LOOPCNT				9
-
-#define EPDC_V2_ENABLE_HW_DITHER			1
-
 #define EPDC_STANDARD_MODE
 
 #define USE_PS_AS_OUTPUT
@@ -182,13 +155,6 @@
 
 //#define EPD_SUSPEND_BLANK			1
 
-#define TCEUNDERRUN_PROC_STAT_OK			0	// non tce underrun
-#define TCEUNDERRUN_PROC_STAT_INT			1 // interrupted .
-#define TCEUNDERRUN_PROC_STAT_PS1			2	// in tce underrun procedure stage 1
-#define TCEUNDERRUN_PROC_STAT_PS2			3 // in tce underrun procedure stage 2 
-#define TCEUNDERRUN_PROC_STAT_PSF			10 // tce underrun procedure stage finished . 
-
-
 #define NTX_WFM_MODE_INIT			0
 #define NTX_WFM_MODE_DU				1
 #define NTX_WFM_MODE_GC16			2
@@ -200,7 +166,6 @@
 #define NTX_WFM_MODE_TOTAL		8
 static int giNTX_waveform_modeA[NTX_WFM_MODE_TOTAL];
 
-volatile static int giLast_waveform_mode = -1;
 
 unsigned char gbModeVersion=0 ;
 unsigned char gbWFM_REV ;
@@ -208,14 +173,11 @@ unsigned char gbFPL_Platform ;
 
 extern int gSleep_Mode_Suspend;
 
+static int vcom_nominal;
 static u64 used_luts = 0x1;	/* do not use LUT0 */
 static unsigned long default_bpp = 16;
 static int vcom_nominal;
 
-#define TCE_STATE_NORMAL			0
-#define TCE_STATE_CRITICAL		1
-static volatile int giTCE_State = TCE_STATE_NORMAL;
-
 static const char gszDisplayReg[]="DISPLAY";
 static const char gszVcomReg[]="VCOM";
 static const char gszVP3V3Reg[]="V3P3";
@@ -355,7 +317,6 @@ struct mxc_epdc_fb_data {
 	u64 epdc_colliding_luts;
 	u64 luts_complete_wb;
 	u64 luts_complete;
-	u64 luts_updating;
 	struct completion updates_done;
 	struct delayed_work epdc_done_work;
 	struct workqueue_struct *epdc_submit_workqueue;
@@ -403,14 +364,11 @@ struct mxc_epdc_fb_data {
 	u8 req_bit;
 	u32 dwSafeTicksEP3V3; // the safe ticks we must to wait for EP3V3 .
 	u32 dwJiffies_To_TurnOFF_EP3V3;// the jiffies value if >= this value , we can turn off the EP3V3 .
+#ifdef ENABLE_EPDC_REUPDATE_WORK//[
+	u32 reupdate_delayms;// delay ms to re-update EPDC by full update to avoid interrupt not comming issue .
 	struct delayed_work epdc_reupdate_work;
+#endif //]ENABLE_EPDC_REUPDATE_WORK
 	struct mxcfb_rect latest_update_region;
-	u32 active_updating_w,active_updating_h;
-	struct mxcfb_rect lut_rect[64];
-	//u32 lut_x[64],lut_y[64];
-	//u32 lut_w[64],lut_h[64];
-	u64 lut_status;
-
 	struct platform_device *pdev;
 
 	/* FB elements related to gen2 waveform data */
@@ -424,18 +382,6 @@ struct mxc_epdc_fb_data {
 	u32 waveform_trc;
 
 	int verbose_lvl;
-
-	int lastest_lut_num;
-	int tce_underrun_proc_stat;
-
-#ifdef TCE_UNDERRUN_PREVENT_WORKFUNC
-	struct delayed_work tce_safe_work;
-	unsigned long tce_safe_ms,tce_safe_freems;
-	int tce_safe_loops;
-	int tce_safe_work_running;
-	int tce_safe_work_cancel;
-	spinlock_t tce_safe_lock;
-#endif //] TCE_UNDERRUN_PREVENT_WORKFUNC
 };
 
 struct waveform_data_header {
@@ -1305,100 +1251,6 @@ static void mxc_epdc_fb_fw_handler(const struct firmware *fw,void *context);
 
 #include "mxc_epdc_fake_s1d13522.c"
 
-void _epdc_qos_setup(void)
-{
-	int ret = 0;
-#ifdef QOS_ENABLE //[
-		if( QOS_SOC_MX6SLL() || QOS_SOC_MX6SL() ) 
-		{
-			unsigned char *reg_qos_base;
-			unsigned long dwQoS_epdc_offset;
-			int iQoS_RD,iQoS_WR;
-			void __iomem *qosc_base;
-			//unsigned char *reg_qos_lcdif,*reg_qos_pxp;
-
-			if( QOS_SOC_MX6SLL() ) {
-				printk("EPDC QoS mx6sll \n");
-				reg_qos_base = 0x02094000;
-				dwQoS_epdc_offset = 0x1800;
-				//reg_qos_epdc = 0x02095800;
-				//reg_qos_lcdif = 0x02096000;
-				//reg_qos_pxp = 0x02095400;
-				iQoS_RD = 0xe0;
-				iQoS_WR = 0xd0;
-			}
-			else {
-				printk("EPDC QoS mx6sl \n");
-				reg_qos_base = 0x02094000;
-				dwQoS_epdc_offset = 0x1400;
-				//reg_qos_epdc = 0x02095400;
-				//reg_qos_lcdif = 0x02095800;
-				//reg_qos_pxp = 0x02095c00;
-				iQoS_RD = 0xe0;
-				iQoS_WR = 0xd0;
-			}
-
-			reg_qos_base = ioremap(reg_qos_base,SZ_16K);
-			if(reg_qos_base == NULL) {
-				ret = -ENOMEM;
-				printk(KERN_ERR"request qos memory failed !\n");
-				goto out;
-			}
-			else {
-
-				printk ("[%s-%d] old masters=0x%08X,epdQos=0x%08X\n",__func__, __LINE__,__raw_readl(reg_qos_base+0x40),__raw_readl(reg_qos_base+dwQoS_epdc_offset));
-				__raw_writel(0,reg_qos_base); // Disable clkgate & soft_reset .
-				__raw_writel(0,reg_qos_base+0x40); // Enable all masters .
-
-				printk ("[%s-%d] new masters=0x%08X,epdQos=0x%08X\n",__func__, __LINE__,__raw_readl(reg_qos_base+0x40),__raw_readl(reg_qos_base+dwQoS_epdc_offset));
-				__raw_writel(0,reg_qos_base+dwQoS_epdc_offset); // Disable clkgate & soft_reset .
-				printk ("[%s-%d] Old QoS_WR=%08X\n",__func__, __LINE__,__raw_readl(reg_qos_base+dwQoS_epdc_offset+iQoS_WR));
-				printk ("[%s-%d] Old QoS_RD=%08X\n",__func__, __LINE__,__raw_readl(reg_qos_base+dwQoS_epdc_offset+iQoS_RD));
-				__raw_writel(0x0f020722,reg_qos_base+dwQoS_epdc_offset+iQoS_WR); // Write QOS,init = 7 with red flag .
-				__raw_writel(0x0f020722,reg_qos_base+dwQoS_epdc_offset+iQoS_RD); // Read QOS, init = 7 with red flag .
-				printk ("[%s-%d] New QoS_WR=%08X\n",__func__, __LINE__,__raw_readl(reg_qos_base+dwQoS_epdc_offset+iQoS_WR));
-				printk ("[%s-%d] New QoS_RD=%08X\n",__func__, __LINE__,__raw_readl(reg_qos_base+dwQoS_epdc_offset+iQoS_RD));
-
-				__raw_readl(reg_qos_base+dwQoS_epdc_offset); // check the QOS value .
-
-				iounmap(reg_qos_base);
-			}
-		}
-		else 
-		if( QOS_SOC_MX6ULL() ) {
-			/* enable the QoS feature to make sure the EPDC has the highest priority. */
-			#define	MX6ULL_GPV0_BASE_ADDR	0x00B00000
-			#define	MX6ULL_PXP_OFFSET_ADDR	69*0x1000
-			#define	MX6ULL_CSI_OFFSET_ADDR	70*0x1000
-			#define	MX6ULL_LCD_OFFSET_ADDR	71*0x1000
-			#define	MX6ULL_EPD_OFFSET_ADDR	72*0x1000
-
-			#define	MX6ULL_QOS_RD	0x100
-			#define	MX6ULL_QOS_WR	0x104
-			void __iomem *nic301_base;
-			nic301_base = ioremap(MX6ULL_GPV0_BASE_ADDR, SZ_1M);
-			if (nic301_base == NULL) {
-				ret = -ENOMEM;
-				goto out;
-			} else {
-				__raw_writel(0x7, nic301_base + MX6ULL_EPD_OFFSET_ADDR  + MX6ULL_QOS_WR); //default 2
-				__raw_writel(0x7, nic301_base + MX6ULL_EPD_OFFSET_ADDR  + MX6ULL_QOS_RD); //default 2
-
-				printk("EPD QOS_WR 0x%x, QOS_RD 0x%x\n",
-				__raw_readl( nic301_base + MX6ULL_EPD_OFFSET_ADDR  + MX6ULL_QOS_WR),
-				__raw_readl( nic301_base + MX6ULL_EPD_OFFSET_ADDR  + MX6ULL_QOS_RD));
-			}
-			
-		}
-		else {
-			printk(KERN_ERR"EPDC_QoS not supported on this platform !\n");
-		}
-	
-#endif //]QOS_ENABLE
-out:
-		return ret;
-}
-
 #ifdef DEBUG
 static void dump_pxp_config(struct mxc_epdc_fb_data *fb_data,
 			    struct pxp_config_data *pxp_conf)
@@ -1868,10 +1720,8 @@ static void epdc_set_update_stride(u32 stride)
 static void epdc_submit_update(u32 lut_num, u32 waveform_mode, u32 update_mode,
 			       bool use_dry_run, bool use_test_mode, u32 np_val)
 {
+	volatile static int giLast_waveform_mode = -1;
 	u32 reg_val = 0;
-
-
-	
 	NTX_TimeStamp_printf("epdc_submite_update",lut_num,"wfm=%hd,updm=%hd;",
 			waveform_mode,update_mode);
 
@@ -1883,27 +1733,13 @@ static void epdc_submit_update(u32 lut_num, u32 waveform_mode, u32 update_mode,
 			EPDC_VPRINT(g_fb_data,1,"%s():waveform mode has been force chage to DU before A2\n",__FUNCTION__);
 		}
 
+		EPDC_VPRINT(g_fb_data,1,"%s(%d):%s(),lut=%d,wf_mode=%d,last_wf_mode=%d,upd_mode=%d,test=%d,np_val=%d\n",
+			__FILE__,__LINE__,__FUNCTION__,lut_num,waveform_mode,giLast_waveform_mode,update_mode,use_test_mode,np_val);
 	}
-	EPDC_VPRINT(g_fb_data,1,"%s(%d):%s(),lut=%d,wf_mode=%d,last_wf_mode=%d,upd_mode=%d,test=%d,np_val=%d\n",
-		__FILE__,__LINE__,__FUNCTION__,lut_num,waveform_mode,giLast_waveform_mode,update_mode,use_test_mode,np_val);
+	else
+		EPDC_VPRINT(g_fb_data,1,"%s(%d):%s(),lut=%d,wf_mode=%d,last_wf_mode=%d,upd_mode=%d,test=%d,np_val=%d\n",
+			__FILE__,__LINE__,__FUNCTION__,lut_num,waveform_mode,giLast_waveform_mode,update_mode,use_test_mode,np_val);
 	
-	if(0!=waveform_mode) {
-#if 0
-		g_fb_data->lut_rect[lut_num].left = g_fb_data->cur_update->update_desc->upd_data.update_region.left;
-		g_fb_data->lut_rect[lut_num].top = g_fb_data->cur_update->update_desc->upd_data.update_region.top;
-		g_fb_data->lut_rect[lut_num].width = g_fb_data->cur_update->update_desc->upd_data.update_region.width;
-		g_fb_data->lut_rect[lut_num].height = g_fb_data->cur_update->update_desc->upd_data.update_region.height;
-#else 
-		g_fb_data->lut_rect[lut_num].left = g_fb_data->latest_update_region.left;
-		g_fb_data->lut_rect[lut_num].top = g_fb_data->latest_update_region.top;
-		g_fb_data->lut_rect[lut_num].width = g_fb_data->latest_update_region.width;
-		g_fb_data->lut_rect[lut_num].height = g_fb_data->latest_update_region.height;
-#endif
-		g_fb_data->active_updating_w += g_fb_data->latest_update_region.width;
-		g_fb_data->active_updating_h += g_fb_data->latest_update_region.height;
-	}
-	EPDC_VPRINT(g_fb_data,2,"%s(),updating w=%hd,h=%hd\n",__FUNCTION__,g_fb_data->active_updating_w,g_fb_data->active_updating_h);
-
 
 	if (use_test_mode) {
 		reg_val |=
@@ -1938,33 +1774,9 @@ static void epdc_submit_update(u32 lut_num, u32 waveform_mode, u32 update_mode,
 	epdc_set_used_lut(lut_num);
 #endif
 	dump_epdc_reg();
-
 	__raw_writel(reg_val, EPDC_UPD_CTRL);
 	giLast_waveform_mode = waveform_mode;
-	
-#ifdef TCE_UNDERRUN_PREVENT_WORKFUNC //[
-
-	if( g_fb_data&&
-			g_fb_data->latest_update_region.width>=TCE_UNDERRUN_PREVENT_X_RES && 
-			g_fb_data->latest_update_region.height>=TCE_UNDERRUN_PREVENT_Y_RES && 
-			( (waveform_mode!=g_fb_data->wv_modes.mode_a2) &&
-				(waveform_mode!=g_fb_data->wv_modes.mode_du) )
-		)
-	{
-		if(g_fb_data->tce_safe_work_running) {
-			g_fb_data->tce_safe_work_cancel = 1;
-		}
-		if(delayed_work_pending(&g_fb_data->tce_safe_work))
-			cancel_delayed_work_sync(&g_fb_data->tce_safe_work);
-		schedule_delayed_work(&g_fb_data->tce_safe_work,msecs_to_jiffies(80));
-	}
-#endif //] TCE_UNDERRUN_PREVENT_WORKFUNC
 
-
-	if(g_fb_data) {
-		g_fb_data->lastest_lut_num=lut_num;
-		g_fb_data->luts_updating |= 1<<lut_num;
-	}
 	
 }
 
@@ -2025,21 +1837,6 @@ static inline bool epdc_any_luts_active(int rev)
 	return any_active;
 }
 
-static inline u64 epdc_luts_status(int rev)
-{
-	u64 luts_status;
-	u32 format_p5n = ((__raw_readl(EPDC_FORMAT) & EPDC_FORMAT_BUF_PIXEL_FORMAT_MASK) ==
-		EPDC_FORMAT_BUF_PIXEL_FORMAT_P5N);
-
-	luts_status = __raw_readl(EPDC_STATUS_LUTS) ;
-	if (rev < 20 || format_p5n)
-		luts_status &= 0xFFFF;
-	else
-		luts_status |= ((u64)__raw_readl(EPDC_STATUS_LUTS2) << 32);
-
-	return luts_status;
-}
-
 static inline bool epdc_any_luts_real_available(void)
 {
 	if ((__raw_readl(EPDC_STATUS_LUTS) != 0xfffffffe) ||
@@ -2244,8 +2041,7 @@ static void epdc_set_vertical_timing(u32 vert_start, u32 vert_end,
 	__raw_writel(reg_val, EPDC_TCE_VSCAN);
 }
 
-#define EPDC_INIT_SETTING_PROC_TCE_RECOVERY 	1
-static void epdc_init_settings_ex(struct mxc_epdc_fb_data *fb_data,int iProcType)
+static void epdc_init_settings(struct mxc_epdc_fb_data *fb_data)
 {
 	struct imx_epdc_fb_mode *epdc_mode = fb_data->cur_mode;
 	struct fb_var_screeninfo *screeninfo = &fb_data->epdc_fb_var;
@@ -2343,13 +2139,13 @@ static void epdc_init_settings_ex(struct mxc_epdc_fb_data *fb_data,int iProcType
 	__raw_writel(reg_val, EPDC_WB_FIELD3);
 #endif
 
-	/* EPDC_FIFOCTRL */
-	reg_val = EPDC_FIFOCTRL_ENABLE_PRIORITY |
-	    ((0 << EPDC_FIFOCTRL_FIFO_INIT_LEVEL_OFFSET) &
+	/* EPDC_FIFOCTRL (disabled) */
+	reg_val =
+	    ((100 << EPDC_FIFOCTRL_FIFO_INIT_LEVEL_OFFSET) &
 	     EPDC_FIFOCTRL_FIFO_INIT_LEVEL_MASK)
-	    | ((255 << EPDC_FIFOCTRL_FIFO_H_LEVEL_OFFSET) &
+	    | ((200 << EPDC_FIFOCTRL_FIFO_H_LEVEL_OFFSET) &
 	       EPDC_FIFOCTRL_FIFO_H_LEVEL_MASK)
-	    | ((254 << EPDC_FIFOCTRL_FIFO_L_LEVEL_OFFSET) &
+	    | ((100 << EPDC_FIFOCTRL_FIFO_L_LEVEL_OFFSET) &
 	       EPDC_FIFOCTRL_FIFO_L_LEVEL_MASK);
 	__raw_writel(reg_val, EPDC_FIFOCTRL);
 
@@ -2530,10 +2326,8 @@ static void epdc_init_settings_ex(struct mxc_epdc_fb_data *fb_data,int iProcType
 	    | EPDC_TCE_POLARITY_GDOE_POL_ACTIVE_HIGH;
 	__raw_writel(reg_val, EPDC_TCE_POLARITY);
 
-	if(0==iProcType) {
-		/* EPDC_IRQ_MASK */
-		__raw_writel(EPDC_IRQ_TCE_UNDERRUN_IRQ, EPDC_IRQ_MASK);
-	}
+	/* EPDC_IRQ_MASK */
+	__raw_writel(EPDC_IRQ_TCE_UNDERRUN_IRQ, EPDC_IRQ_MASK);
 
 	/*
 	 * EPDC_GPIO
@@ -2555,18 +2349,11 @@ static void epdc_init_settings_ex(struct mxc_epdc_fb_data *fb_data,int iProcType
 		bb_p++;
 	}
 
-	if(0==iProcType) {
-		/* Disable clock */
-		clk_disable_unprepare(fb_data->epdc_clk_axi);
-		clk_disable_unprepare(fb_data->epdc_clk_pix);
-	}
-}
-static void epdc_init_settings(struct mxc_epdc_fb_data *fb_data)
-{
-	epdc_init_settings_ex(fb_data,0);
+	/* Disable clock */
+	clk_disable_unprepare(fb_data->epdc_clk_axi);
+	clk_disable_unprepare(fb_data->epdc_clk_pix);
 }
 
-
 static void epdc_powerup(struct mxc_epdc_fb_data *fb_data)
 {
 	struct epd_vc_data vcd;
@@ -2574,6 +2361,9 @@ static void epdc_powerup(struct mxc_epdc_fb_data *fb_data)
 
 	mutex_lock(&fb_data->power_mutex);
 
+#ifdef ENABLE_EPDC_REUPDATE_WORK//[
+	cancel_delayed_work_sync(&fb_data->epdc_reupdate_work);
+#endif //]ENABLE_EPDC_REUPDATE_WORK
 	
 
 	/*
@@ -2584,12 +2374,12 @@ static void epdc_powerup(struct mxc_epdc_fb_data *fb_data)
 		fb_data->powering_down = false;
 
 	if (fb_data->power_state == POWER_STATE_ON) {
-		EPDC_VPRINT(fb_data,5, "EPD skipped pwrup, state=%d (ON)\n",fb_data->power_state);
+		dev_dbg(fb_data->dev, "EPD skipped pwrup, state=%d (ON)\n",fb_data->power_state);
 		mutex_unlock(&fb_data->power_mutex);
 		return;
 	}
 
-	EPDC_VPRINT(fb_data,3,"EPDC Powerup\n");
+	dev_dbg(fb_data->dev, "EPDC Powerup\n");
 	NTX_TimeStamp_In("epdc_pwrup",0);
 
 	fb_data->updates_active = true;
@@ -2682,6 +2472,11 @@ static void epdc_powerup(struct mxc_epdc_fb_data *fb_data)
 	k_set_temperature(&fb_data->info);
 
 	fb_data->power_state = POWER_STATE_ON;
+#ifdef ENABLE_EPDC_REUPDATE_WORK//[
+	schedule_delayed_work(&fb_data->epdc_reupdate_work,
+		msecs_to_jiffies(fb_data->pwrdown_delay)+
+		msecs_to_jiffies(fb_data->reupdate_delayms));
+#endif //]ENABLE_EPDC_REUPDATE_WORK
 
 
 	mutex_unlock(&fb_data->power_mutex);
@@ -2691,6 +2486,9 @@ static void epdc_powerdown(struct mxc_epdc_fb_data *fb_data)
 {
 	mutex_lock(&fb_data->power_mutex);
 
+#ifdef ENABLE_EPDC_REUPDATE_WORK//[
+	cancel_delayed_work_sync(&fb_data->epdc_reupdate_work);
+#endif //]ENABLE_EPDC_REUPDATE_WORK
 
 	/* If powering_down has been cleared, a powerup
 	 * request is pre-empting this powerdown request.
@@ -2698,13 +2496,13 @@ static void epdc_powerdown(struct mxc_epdc_fb_data *fb_data)
 	if (!fb_data->powering_down
 		|| (fb_data->power_state == POWER_STATE_OFF)) {
 		mutex_unlock(&fb_data->power_mutex);
-		EPDC_VPRINT(fb_data,5, "EPDC skipped pwrdwn,state=%d,powering_down=%d \n",
+		dev_dbg(fb_data->dev, "EPDC skipped pwrdwn,state=%d,powering_down=%d \n",
 			fb_data->power_state,fb_data->powering_down);
 		return;
 	}
 
 	NTX_TimeStamp_In("epdc_pwrdown",0);
-	EPDC_VPRINT(fb_data,3, "EPDC Powerdown\n");
+	dev_dbg(fb_data->dev, "EPDC Powerdown\n");
 
 	/* Disable power to the EPD panel */
 	regulator_disable(fb_data->vcom_regulator);
@@ -2734,40 +2532,6 @@ static void epdc_powerdown(struct mxc_epdc_fb_data *fb_data)
 	mutex_unlock(&fb_data->power_mutex);
 }
 
-
-#ifdef TCE_UNDERRUN_PREVENT_WORKFUNC//[
-static void tce_safe_work_func(struct work_struct *work)
-{
-	struct mxc_epdc_fb_data *fb_data =
-		container_of(work, struct mxc_epdc_fb_data,
-			tce_safe_work.work);
-	int i;
-	unsigned long flags;
-
-	fb_data->tce_safe_work_running = 1;
-	EPDC_VPRINT(fb_data,0,"%s() start\n",__FUNCTION__);
-	for(i=0;i<fb_data->tce_safe_loops;i++)
-	{
-		if(fb_data->tce_safe_work_cancel) {
-			fb_data->tce_safe_work_cancel = 0;
-			EPDC_VPRINT(fb_data,0,"%s() cancel\n",__FUNCTION__);
-			break;
-		}
-		EPDC_VPRINT(fb_data,0,"*",__FUNCTION__);
-		//spin_lock_irqsave(&fb_data->tce_safe_lock,flags);
-		spin_lock(&fb_data->tce_safe_lock);
-		mdelay(fb_data->tce_safe_ms);
-		spin_unlock(&fb_data->tce_safe_lock);
-		//spin_unlock_irqrestore(&fb_data->tce_safe_lock,flags);
-		msleep(fb_data->tce_safe_freems);
-	}
-	EPDC_VPRINT(fb_data,0,"%s() end\n",__FUNCTION__);
-
-	fb_data->tce_safe_work_running = 0;
-	return ;
-}
-#endif //]TCE_UNDERRUN_PREVENT_WORKFUNC
-
 static void epdc_init_sequence(struct mxc_epdc_fb_data *fb_data)
 {
 	/* Initialize EPDC, passing pointer to EPDC registers */
@@ -3412,11 +3176,11 @@ static int mxc_epdc_fb_get_temp_index(struct mxc_epdc_fb_data *fb_data, int temp
 		dev_err(fb_data->dev,
 			"No TRT index match (%d)\n", temp);
 		if (temp < fb_data->temp_range_bounds[0]) {
-			dev_warn(fb_data->dev, "temperature < minimum range\n");
+			dev_dbg(fb_data->dev, "temperature < minimum range\n");
 			return 0;
 		}
 		if (temp >= fb_data->temp_range_bounds[fb_data->trt_entries-1]) {
-			dev_warn(fb_data->dev, "temperature >= maximum range\n");
+			dev_dbg(fb_data->dev, "temperature >= maximum range\n");
 			return (fb_data->trt_entries-1);
 		}
 		return DEFAULT_TEMP_INDEX;
@@ -3455,7 +3219,6 @@ static int mxc_epdc_fb_set_temperature(int temperature, struct fb_info *info)
 	struct mxc_epdc_fb_data *fb_data = info ?
 		(struct mxc_epdc_fb_data *)info:g_fb_data;
 
-	EPDC_VPRINT(fb_data,3,"%s()\n",__FUNCTION__);
 	/* Store temp index. Used later when configuring updates. */
 	mutex_lock(&fb_data->queue_mutex);
 	fb_data->temp_index = mxc_epdc_fb_get_temp_index(fb_data, temperature);
@@ -3507,26 +3270,8 @@ static int mxc_epdc_fb_set_upd_scheme(u32 upd_scheme, struct fb_info *info)
 
 	if ((upd_scheme == UPDATE_SCHEME_SNAPSHOT)
 		|| (upd_scheme == UPDATE_SCHEME_QUEUE)
-		|| (upd_scheme == UPDATE_SCHEME_QUEUE_AND_MERGE)) 
-	{
-
-		switch (upd_scheme) {
-		case UPDATE_SCHEME_SNAPSHOT:
-			printk(KERN_ERR"update scheme <= snapshot\n");
-			break;
-		case UPDATE_SCHEME_QUEUE:
-			printk(KERN_ERR"update scheme <= queue\n");
-			break;
-		case UPDATE_SCHEME_QUEUE_AND_MERGE:
-			printk(KERN_ERR"update scheme <= queue and merge\n");
-			break;
-		default :
-			printk(KERN_ERR"update scheme <= unknow \n");
-			break;
-		}
-
+		|| (upd_scheme == UPDATE_SCHEME_QUEUE_AND_MERGE))
 		fb_data->upd_scheme = upd_scheme;
-	}
 	else {
 		dev_err(fb_data->dev, "Invalid update scheme specified.\n");
 		return -EINVAL;
@@ -3667,8 +3412,7 @@ static int epdc_working_buffer_update(struct mxc_epdc_fb_data *fb_data,
 	}
 
 	if (fb_data->col_info.pixel_cnt) {
-		//dev_dbg(fb_data->dev, "collision detected, can not do REAGl/-D\n");
-		EPDC_VPRINT(fb_data,3,"collision detected, can not do REAGl/-D\n");
+		dev_info(fb_data->dev, "collision detected, can not do REAGl/-D\n");
 		mutex_unlock(&fb_data->pxp_mutex);
 		return 0;
 	}
@@ -4174,20 +3918,6 @@ static void epdc_firmware_work_func(struct work_struct *work)
 
 #endif //] FW_IN_RAM
 
-#define min(a,b)	(((a)>(b))?b:a)
-#define max(a,b)	(((a)>(b))?a:b)
-static inline int _is_region_overlap(struct mxcfb_rect *r1,struct mxcfb_rect *r2)
-{
-	int x_overlap = min(r1->left+r1->width,r2->left+r2->width) - max(r1->left,r2->left);
-	int y_overlap = min(r1->top+r1->height,r2->top+r2->height) - max(r1->top,r2->top);
-	//printk("x_overlap=%d,y_overlap=%d\n",x_overlap,y_overlap);
-
-	x_overlap=(x_overlap<0)?0:x_overlap;
-	y_overlap=(y_overlap<0)?0:y_overlap;
-	//return (x_overlap*y_overlap);
-	return (x_overlap&&y_overlap);
-}
-
 static void epdc_submit_work_func(struct work_struct *work)
 {
 	int temp_index;
@@ -4205,15 +3935,6 @@ static void epdc_submit_work_func(struct work_struct *work)
 	u32 update_addr;
 	int *err_dist;
 	int ret;
-#if DROP_OLD_COLLISION //[
-	bool ignore_this_collision ;
-	u32 lut;
-#endif //]DROP_OLD_COLLISION
-
-	EPDC_VPRINT(fb_data,6,"%s() begin-updating w=%d,h=%d\n",
-			__FUNCTION__,fb_data->active_updating_w,fb_data->active_updating_h);
-
-
 
 	/* Protect access to buffer queues and to update HW */
 	mutex_lock(&fb_data->queue_mutex);
@@ -4226,88 +3947,10 @@ static void epdc_submit_work_func(struct work_struct *work)
 	list_for_each_entry_safe(next_update, temp_update,
 				&fb_data->upd_buf_collision_list, list) {
 
-
-
 		if (next_update->collision_mask != 0)
 			continue;
 
-#if DROP_OLD_COLLISION //[
-		/*
-		 * If we collide with newer updates, then
-		 * we don't need to re-submit the update. The
-		 * idea is that the newer updates should take
-		 * precedence anyways, so we don't want to
-		 * overwrite them.
-		 */
-		
-		for (ignore_this_collision = false, lut = 0;
-				lut<fb_data->num_luts;lut++) 
-		{
-			if(fb_data->lut_update_order[lut]) 
-			{
-				if ( (fb_data->lut_update_order[lut] >
-					next_update->update_desc->update_order) ) 
-				{
-					
-					struct mxcfb_rect adj_update_region;
-					
-					adjust_coordinates(fb_data->epdc_fb_var.xres,
-						fb_data->epdc_fb_var.yres, fb_data->epdc_fb_var.rotate,
-						&next_update->update_desc->upd_data.update_region,
-						&adj_update_region);
-
-					EPDC_VPRINT(fb_data,1,
-						"checking collision (lut%d,order=%d<%d) with newer update.\n",
-						next_update->lut_num,
-						next_update->update_desc->update_order,
-						fb_data->lut_update_order[lut] );
-
-					EPDC_VPRINT(fb_data,2,"check r1(%d,%d,%d,%d),r2(%d,%d,%d,%d) overlapping\n",
-						fb_data->lut_rect[lut].left,
-						fb_data->lut_rect[lut].top,
-						fb_data->lut_rect[lut].width,
-						fb_data->lut_rect[lut].height,
-						adj_update_region.left,
-						adj_update_region.top,
-						adj_update_region.width,
-						adj_update_region.height);
-
-					if(_is_region_overlap(&fb_data->lut_rect[lut],&adj_update_region) &&
-					 fb_data->lut_rect[lut].left==adj_update_region.left &&
-					 fb_data->lut_rect[lut].top==adj_update_region.top &&
-					 fb_data->lut_rect[lut].width==adj_update_region.width &&
-					 fb_data->lut_rect[lut].height==adj_update_region.height )
-					{
-
-						EPDC_VPRINT(fb_data,1,"ignore overlapping collision r1(%d,%d,%d,%d),r2(%d,%d,%d,%d)\n",
-							fb_data->lut_rect[lut].left,
-							fb_data->lut_rect[lut].top,
-							fb_data->lut_rect[lut].width,
-							fb_data->lut_rect[lut].height,
-							adj_update_region.left,
-							adj_update_region.top,
-							adj_update_region.width,
-							adj_update_region.height);
-						ignore_this_collision = true;
-					}
-					break;
-				}
-			}
-		}
-
-		if(ignore_this_collision) {
-			list_del_init(&next_update->update_desc->list);
-			kfree(next_update->update_desc);
-			list_del_init(&next_update->list);
-			list_add_tail(&next_update->list,&fb_data->upd_buf_free_list);
-			//list_del(&next_update->list);
-			break;
-		}
-
-#endif //] DROP_OLD_COLLISION
-
 		dev_dbg(fb_data->dev, "A collision update is ready to go!\n");
-		EPDC_VPRINT(fb_data,3, "A collision update is ready to go!\n");
 
 		/* Force waveform mode to auto for resubmitted collisions */
 		next_update->update_desc->upd_data.waveform_mode =
@@ -4330,8 +3973,6 @@ static void epdc_submit_work_func(struct work_struct *work)
 			case MERGE_OK:
 				dev_dbg(fb_data->dev,
 					"Update merged [collision]\n");
-				EPDC_VPRINT(fb_data,3,
-					"Update merged [collision]\n");
 				list_del_init(&next_update->update_desc->list);
 				kfree(next_update->update_desc);
 				next_update->update_desc = NULL;
@@ -4343,14 +3984,10 @@ static void epdc_submit_work_func(struct work_struct *work)
 			case MERGE_FAIL:
 				dev_dbg(fb_data->dev,
 					"Update not merged [collision]\n");
-				EPDC_VPRINT(fb_data,3,
-					"Update not merged [collision]\n");
 				break;
 			case MERGE_BLOCK:
 				dev_dbg(fb_data->dev,
 					"Merge blocked [collision]\n");
-				EPDC_VPRINT(fb_data,3,
-					"Merge blocked [collision]\n");
 				end_merge = true;
 				break;
 			}
@@ -4387,7 +4024,6 @@ static void epdc_submit_work_func(struct work_struct *work)
 				&fb_data->upd_pending_list, list) {
 
 			dev_dbg(fb_data->dev, "Found a pending update!\n");
-			EPDC_VPRINT(fb_data,3, "Found a pending update!\n");
 
 			if (!upd_data_list) {
 				if (list_empty(&fb_data->upd_buf_free_list))
@@ -4407,22 +4043,16 @@ static void epdc_submit_work_func(struct work_struct *work)
 				case MERGE_OK:
 					dev_dbg(fb_data->dev,
 						"Update merged [queue]\n");
-					EPDC_VPRINT(fb_data,3,
-						"Update merged [queue]\n");
 					list_del_init(&next_desc->list);
 					kfree(next_desc);
 					break;
 				case MERGE_FAIL:
 					dev_dbg(fb_data->dev,
 						"Update not merged [queue]\n");
-					EPDC_VPRINT(fb_data,3,
-						"Update not merged [queue]\n");
 					break;
 				case MERGE_BLOCK:
 					dev_dbg(fb_data->dev,
 						"Merge blocked [collision]\n");
-					EPDC_VPRINT(fb_data,3,
-						"Merge blocked [collision]\n");
 					end_merge = true;
 					break;
 				}
@@ -4491,91 +4121,6 @@ static void epdc_submit_work_func(struct work_struct *work)
 		/* Release buffer queues */
 		mutex_unlock(&fb_data->queue_mutex);
 
-
-#if 1
-		// waiting for tce underrun recovery process .
-		if(fb_data->tce_underrun_proc_stat>=TCEUNDERRUN_PROC_STAT_INT &&
-			 TCE_UNDERRUN_RECOVER_MARKERNO!=upd_data_list->update_desc->upd_data.update_marker )
-		{
-			int i,iMaxWaitCnt=(TCE_UNDERRUN_RECOVERY_UPDATE_DELAYMS/10)+60;
-			giTCE_State = TCE_STATE_CRITICAL;
-			printk(KERN_ERR"%s(%d) skipped when tce underrun recovering \n",__FUNCTION__,__LINE__);
-			for(i=0;fb_data->tce_underrun_proc_stat>TCEUNDERRUN_PROC_STAT_INT;i++) {
-				
-				printk(KERN_ERR".",__FUNCTION__,__LINE__);
-				msleep(10);
-				if(i>=iMaxWaitCnt) {
-					printk(KERN_ERR"tce underrun wait recovering timeout\n");
-					break;
-				}
-			}
-			giTCE_State = TCE_STATE_NORMAL;
-
-			if(i<iMaxWaitCnt) {
-				printk(KERN_ERR"tce underrun recovering done\n");
-			}
-		}
-#endif
-
-#if (TCE_UNDERRUN_PREVENT_PATCH==2) // .
-		// postpone submit update to avoid TCE underrun
-		if(	fb_data->cur_mode->vmode->pixclock >= TCE_UNDERRUN_PREVENT_PIXCLK && 
-				fb_data->cur_mode->vmode->xres>=TCE_UNDERRUN_PREVENT_X_RES && 
-				fb_data->cur_mode->vmode->yres>=TCE_UNDERRUN_PREVENT_Y_RES )
-		{
-			int i,iMaxWaitCnt=50;
-			//int iUPD_RES = fb_data->active_updating_w*fb_data->active_updating_h;
-			int iUPD_RES = fb_data->cur_mode->vmode->xres*fb_data->active_updating_h;
-			u64 lut_status = fb_data->lut_status;
-			int iActLuts;
-
-			for(iActLuts=1,i=0;i<64;i++) {
-				if(lut_status&(u64)(1ULL<<i))
-					iActLuts++;
-			}
-
-			if( iUPD_RES >= ((fb_data->cur_mode->vmode->xres*fb_data->cur_mode->vmode->yres)/iActLuts)
-					&& ( (giLast_waveform_mode!=fb_data->wv_modes.mode_a2) &&
-						   (giLast_waveform_mode!=fb_data->wv_modes.mode_du) )
-#if 0
-					&& ( ((fb_data->wv_modes.mode_aa!=fb_data->wv_modes.mode_gl16)&&(giLast_waveform_mode == fb_data->wv_modes.mode_aa)) ||
-					((fb_data->wv_modes.mode_aad!=fb_data->wv_modes.mode_gc16)&&(giLast_waveform_mode == fb_data->wv_modes.mode_aad)) )
-#endif
-				)
-			{
-				giTCE_State = TCE_STATE_CRITICAL;
-				EPDC_VPRINT(fb_data,1,"%s():waiting for lut%d/%d complete to submit update ...\n",
-					__FUNCTION__,fb_data->lastest_lut_num,iActLuts);
-
-
-				for(i=0;i<iMaxWaitCnt;i++) {
-					EPDC_VPRINT(fb_data,1,".");
-#if 0
-					// system will halt .
-					if(epdc_is_lut_complete(fb_data->rev,fb_data->lastest_lut_num))
-#else
-					if( !(fb_data->luts_updating & (1<<fb_data->lastest_lut_num)) )
-#endif
-					{
-						EPDC_VPRINT(fb_data,1,"%s() : lut%d complete !\n",
-							__FUNCTION__,fb_data->lastest_lut_num);
-						break;
-					}
-					msleep(10);
-				}
-				giTCE_State = TCE_STATE_NORMAL;
-				if(i>=iMaxWaitCnt) {
-					EPDC_VPRINT(fb_data,1,"\n%s(): waiting for lut%d complete %dms timeout !!\n",__FUNCTION__,fb_data->lastest_lut_num,10*i);
-				}
-				else {
-					EPDC_VPRINT(fb_data,1,"\n%s(): lut%d wait %dms done, submitting update !!\n",__FUNCTION__,fb_data->lastest_lut_num,10*i);
-				}
-
-			}
-		}
-#endif//] (TCE_UNDERRUN_PREVENT_PATCH==2)
-
-
 		/* Perform PXP processing - EPDC power will also be enabled */
 		if (epdc_process_update(upd_data_list, fb_data)) {
 			dev_err(fb_data->dev, "PXP processing error.\n");
@@ -4614,7 +4159,7 @@ static void epdc_submit_work_func(struct work_struct *work)
 	 * to become free. The IST will signal this event.
 	 */
 	if (fb_data->cur_update != NULL) {
-		dev_warn(fb_data->dev, "working buf busy!\n");
+		dev_dbg(fb_data->dev, "working buf busy!\n");
 
 		/* Initialize event signalling an update resource is free */
 		init_completion(&fb_data->update_res_free);
@@ -4681,7 +4226,7 @@ static void epdc_submit_work_func(struct work_struct *work)
 		luts_available = fb_data->epdc_wb_mode ? epdc_any_luts_real_available() :
 							 epdc_any_luts_available();
 		if (!luts_available) {
-			dev_warn(fb_data->dev, "no luts available!\n");
+			dev_dbg(fb_data->dev, "no luts available!\n");
 
 			/* Initialize event signalling an update resource is free */
 			init_completion(&fb_data->update_res_free);
@@ -4754,11 +4299,6 @@ static void epdc_submit_work_func(struct work_struct *work)
 		fb_data->lut_update_order[upd_data_list->lut_num] =
 			upd_data_list->update_desc->update_order;
 
-		EPDC_VPRINT(fb_data,1,"%s,%d,%s() : lut%d's order=%d,flags=0x%x\n",
-				__FILE__,__LINE__,__FUNCTION__,
-				upd_data_list->lut_num,upd_data_list->update_desc->update_order,
-				upd_data_list->update_desc->upd_data.flags);
-
 		epdc_lut_complete_intr(fb_data->rev, upd_data_list->lut_num,
 					true);
 	}
@@ -5232,10 +4772,6 @@ static int mxc_epdc_fb_send_single_update(struct mxcfb_update_data *upd_data,
 		fb_data->lut_update_order[upd_data_list->lut_num] =
 			upd_desc->update_order;
 
-		EPDC_VPRINT(fb_data,1,"%s,%d,%s() : lut%d's order=%d\n",
-				__FILE__,__LINE__,__FUNCTION__,
-				upd_data_list->lut_num,upd_desc->update_order);
-
 		epdc_lut_complete_intr(fb_data->rev, upd_data_list->lut_num,
 					true);
 	}
@@ -5921,6 +5457,8 @@ static struct fb_deferred_io mxc_epdc_fb_defio = {
 	.deferred_io = mxc_epdc_fb_deferred_io,
 };
 
+#ifdef ENABLE_EPDC_REUPDATE_WORK//[
+
 
 static void epdc_reupdate_work_func(struct work_struct *work)
 {
@@ -5934,8 +5472,7 @@ static void epdc_reupdate_work_func(struct work_struct *work)
 	unsigned long update_marker_num = 0;
 	__u32 w,h,x,y;
 
-	int iTCE_Underrun_Proc = 
-		(fb_data->tce_underrun_proc_stat>=TCEUNDERRUN_PROC_STAT_PS1)?1:0;
+
 
 
 	l_upd_data.update_mode = UPDATE_MODE_FULL;
@@ -5945,21 +5482,19 @@ static void epdc_reupdate_work_func(struct work_struct *work)
 	l_upd_data.update_marker = update_marker_num;
 
 
-	if(iTCE_Underrun_Proc) {
-		update_marker_num = TCE_UNDERRUN_RECOVER_MARKERNO;
-		x = 0;
-		y = 0;
-		w = fb_data->epdc_fb_var.xres;
-		h = fb_data->epdc_fb_var.yres;
-		printk(KERN_ERR"%s(),TCE underrun,x=%d,y=%d,w=%d,h=%d\n",__FUNCTION__,(int)x,(int)y,(int)w,(int)h);
-	}
-	else {
+	if(FB_ROTATE_UD==fb_data->epdc_fb_var.rotate || FB_ROTATE_UR==fb_data->epdc_fb_var.rotate) {
 		x = fb_data->latest_update_region.left;
 		y = fb_data->latest_update_region.top;
 		w = fb_data->latest_update_region.width;
 		h = fb_data->latest_update_region.height;
-		printk(KERN_ERR"%s(),x=%d,y=%d,w=%d,h=%d\n",__FUNCTION__,(int)x,(int)y,(int)w,(int)h);
 	}
+	else {
+		y = fb_data->latest_update_region.left;
+		x = fb_data->latest_update_region.top;
+		w = fb_data->latest_update_region.height;
+		h = fb_data->latest_update_region.width;
+	}
+	printk("%s(),x=%d,y=%d,w=%d,h=%d\n",__FUNCTION__,(int)x,(int)y,(int)w,(int)h);
 
 	l_upd_data.update_region.width = w;
 	l_upd_data.update_region.height = h;
@@ -5971,12 +5506,9 @@ static void epdc_reupdate_work_func(struct work_struct *work)
 	l_mxc_upd_marker_data.collision_test = 0;
 	l_mxc_upd_marker_data.update_marker = update_marker_num;
 	iChk = mxc_epdc_fb_wait_update_complete(&l_mxc_upd_marker_data,&fb_data->info);
-
-	if(iTCE_Underrun_Proc) {
-		fb_data->tce_underrun_proc_stat = TCEUNDERRUN_PROC_STAT_OK;
-	}
-	printk(KERN_ERR"%s(),x=%d,y=%d,w=%d,h=%d reupdate done \n",__FUNCTION__,(int)x,(int)y,(int)w,(int)h);
+	
 }
+#endif //]ENABLE_EPDC_REUPDATE_WORK
 
 static void epdc_done_work_func(struct work_struct *work)
 {
@@ -6006,7 +5538,6 @@ static irqreturn_t mxc_epdc_irq_handler(int irq, void *dev_id)
 {
 	struct mxc_epdc_fb_data *fb_data = dev_id;
 	u32 ints_fired, luts1_ints_fired, luts2_ints_fired;
-	u32 epdc_irq_stat;
 
 	/*
 	 * If we just completed one-time panel init, bypass
@@ -6016,14 +5547,14 @@ static irqreturn_t mxc_epdc_irq_handler(int irq, void *dev_id)
 		if (epdc_is_working_buffer_complete()) {
 			epdc_working_buf_intr(false);
 			epdc_clear_working_buf_irq();
-			dev_info(fb_data->dev, "Cleared WB for init update\n");
+			dev_dbg(fb_data->dev, "Cleared WB for init update\n");
 		}
 
 		if (epdc_is_lut_complete(fb_data->rev, 0)) {
 			epdc_lut_complete_intr(fb_data->rev, 0, false);
 			epdc_clear_lut_complete_irq(fb_data->rev, 0);
 			fb_data->in_init = false;
-			dev_info(fb_data->dev, "Cleared LUT complete for init update\n");
+			dev_dbg(fb_data->dev, "Cleared LUT complete for init update\n");
 		}
 
 		return IRQ_HANDLED;
@@ -6041,46 +5572,17 @@ static irqreturn_t mxc_epdc_irq_handler(int irq, void *dev_id)
 	if (!(ints_fired || luts1_ints_fired || luts2_ints_fired))
 		return IRQ_HANDLED;
 
-	epdc_irq_stat = __raw_readl(EPDC_IRQ);
-	if (epdc_irq_stat & EPDC_IRQ_TCE_UNDERRUN_IRQ) {
+	if (__raw_readl(EPDC_IRQ) & EPDC_IRQ_TCE_UNDERRUN_IRQ) {
 		dev_err(fb_data->dev,
-			"TCE underrun! Will continue to update panel,irq_stat=0x%x\n",epdc_irq_stat);
-		if(TCEUNDERRUN_PROC_STAT_OK!=fb_data->tce_underrun_proc_stat)
-		{
-			dev_err(fb_data->dev,
-				"TCE underrun is comming when procedure in progress .\n");
-		}
-#if (TCE_UNDERRUN_RECOVERY==1) //[
-		// nop . 
-		fb_data->tce_underrun_proc_stat = TCEUNDERRUN_PROC_STAT_INT;
-#elif (TCE_UNDERRUN_RECOVERY==2) //[
-		__raw_writel(EPDC_IRQ_TCE_UNDERRUN_IRQ, EPDC_IRQ_CLEAR);
-
-		if(TCEUNDERRUN_PROC_STAT_OK!=fb_data->tce_underrun_proc_stat) {
-			cancel_delayed_work_sync(&fb_data->epdc_reupdate_work);
-		}
-		else {
-			fb_data->tce_underrun_proc_stat = TCEUNDERRUN_PROC_STAT_PS1;
-		}
-		schedule_delayed_work(&fb_data->epdc_reupdate_work,msecs_to_jiffies(TCE_UNDERRUN_RECOVERY_UPDATE_DELAYMS));
-#else //][! (TCE_UNDERRUN_RECOVERY==1)
+			"TCE underrun! Will continue to update panel\n");
 		/* Clear TCE underrun IRQ */
 		__raw_writel(EPDC_IRQ_TCE_UNDERRUN_IRQ, EPDC_IRQ_CLEAR);
-#endif //] (TCE_UNDERRUN_RECOVERY==1)
 	}
 
 	/* Check if we are waiting on EOF to sync a new update submission */
 	if (epdc_signal_eof()) {
 		epdc_eof_intr(false);
 		epdc_clear_eof_irq();
-
-#if (TCE_UNDERRUN_RECOVERY==1) //[
-		if(TCEUNDERRUN_PROC_STAT_INT==fb_data->tce_underrun_proc_stat) {
-			dev_err(fb_data->dev,"TCE underrun-> frame end \n");
-			fb_data->tce_underrun_proc_stat = TCEUNDERRUN_PROC_STAT_PS1;
-		}
-#endif //]
-
 		complete(&fb_data->eof_event);
 	}
 
@@ -6113,72 +5615,6 @@ static irqreturn_t mxc_epdc_irq_handler(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static void epdc_recovery(struct mxc_epdc_fb_data *fb_data)
-{
-	struct mxcfb_update_data l_upd_data;
-	int iQueueLockOrgState;
-
-#ifdef TCE_UNDERRUN_PREVENT_WORKFUNC//[
-	if(g_fb_data->tce_safe_work_running) {
-		g_fb_data->tce_safe_work_cancel = 1;
-	}
-#endif //]TCE_UNDERRUN_PREVENT_WORKFUNC
-
-	msleep(50);
-	printk(KERN_WARNING"epdc reinit ...\n");
-
-	iQueueLockOrgState = mutex_is_locked(&fb_data->queue_mutex); 
-	if(!iQueueLockOrgState) {
-		mutex_lock(&fb_data->queue_mutex);
-	}
-
-	//fb_data->in_init = true;
-	//epdc_init_sequence(fb_data);
-	epdc_init_settings_ex(fb_data,EPDC_INIT_SETTING_PROC_TCE_RECOVERY);
-	//fb_data->tce_underrun_proc_stat=TCEUNDERRUN_PROC_STAT_PSF;
-	fb_data->tce_underrun_proc_stat=TCEUNDERRUN_PROC_STAT_OK;
-	fb_data->updates_active = false;
-
-	msleep(100);
-
-	//printk("epdc powerdown ...\n");
-	//fb_data->powering_down = true;
-	//epdc_powerdown(fb_data);
-	
-
-	fb_data->luts_updating &= ~(u64)(1ULL<<fb_data->lastest_lut_num);
-
-	printk(KERN_WARNING"resending last rect update ...\n");
-	l_upd_data.update_mode = UPDATE_MODE_FULL;
-	l_upd_data.waveform_mode = fb_data->wv_modes.mode_gc16;
-	l_upd_data.temp = TEMP_USE_AMBIENT;
-	l_upd_data.flags = 0;
-	l_upd_data.update_marker = 0;
-	l_upd_data.dither_mode = 0;
-	l_upd_data.quant_bit = 0;
-
-	if(FB_ROTATE_UD==fb_data->epdc_fb_var.rotate || FB_ROTATE_UR==fb_data->epdc_fb_var.rotate) {
-		l_upd_data.update_region.width = fb_data->latest_update_region.width;
-		l_upd_data.update_region.height = fb_data->latest_update_region.height;
-		l_upd_data.update_region.left = fb_data->latest_update_region.left;
-		l_upd_data.update_region.top = fb_data->latest_update_region.top;
-	}
-	else {
-		l_upd_data.update_region.height = fb_data->latest_update_region.width;
-		l_upd_data.update_region.width = fb_data->latest_update_region.height;
-		l_upd_data.update_region.left = fb_data->latest_update_region.left;
-		l_upd_data.update_region.top = fb_data->latest_update_region.top;
-	}
-
-
-	mutex_unlock(&fb_data->queue_mutex);
-	mxc_epdc_fb_send_single_update(&l_upd_data,&fb_data->info);
-	if(iQueueLockOrgState) {
-		mutex_lock(&fb_data->queue_mutex);
-	}
-	printk(KERN_WARNING"epdc recovery end\n");
-}
-
 static void epdc_intr_work_func(struct work_struct *work)
 {
 	struct mxc_epdc_fb_data *fb_data =
@@ -6201,12 +5637,8 @@ static void epdc_intr_work_func(struct work_struct *work)
 	bool epdc_waiting_on_wb;
 	u32 coll_coord, coll_size;
 	struct mxcfb_rect coll_region;
-
-
 	GALLEN_DBGLOCAL_BEGIN_EX(64);
 
-	fb_data->lut_status = epdc_luts_status(fb_data->rev);
-
 	/* Protect access to buffer queues and to update HW */
 	mutex_lock(&fb_data->queue_mutex);
 
@@ -6241,33 +5673,6 @@ static void epdc_intr_work_func(struct work_struct *work)
 			((u64)__raw_readl(EPDC_IRQ2) << 32);
 	epdc_waiting_on_wb = (fb_data->cur_update != NULL) ? true : false;
 
-
-	//if(fb_data->tce_underrun_proc_stat) 
-	{
-		EPDC_VPRINT(fb_data,10,"irq_stat=0x%llx\n",epdc_irq_stat);
-		EPDC_VPRINT(fb_data,10,"wb_busy=%x\n",epdc_wb_busy);
-		EPDC_VPRINT(fb_data,2,"luts_status=0x%x\n",epdc_luts_status(fb_data->rev));
-		EPDC_VPRINT(fb_data,2,"luts_active=%x\n",epdc_luts_active);
-		EPDC_VPRINT(fb_data,10,"luts_avail=%x\n",epdc_luts_avail);
-		EPDC_VPRINT(fb_data,10,"luts_canelled=%x\n",epdc_lut_cancelled);
-		EPDC_VPRINT(fb_data,10,"epdc_collision=%x\n",epdc_collision);
-		EPDC_VPRINT(fb_data,2,"no pending=%d\n",list_empty(&fb_data->upd_pending_list));
-		EPDC_VPRINT(fb_data,2,"free list full=%d\n",is_free_list_full(fb_data));
-		EPDC_VPRINT(fb_data,2,"waiting on wb=%d\n",epdc_waiting_on_wb);
-	}
-
-#if (TCE_UNDERRUN_RECOVERY==1) //[
-	if(TCEUNDERRUN_PROC_STAT_PS1==fb_data->tce_underrun_proc_stat) {
-		epdc_recovery(fb_data);
-		/* Clear TCE underrun IRQ */
-		__raw_writel(EPDC_IRQ_TCE_UNDERRUN_IRQ, EPDC_IRQ_MASK);
-		__raw_writel(EPDC_IRQ_TCE_UNDERRUN_IRQ, EPDC_IRQ_CLEAR);
-		mutex_unlock(&fb_data->queue_mutex);
-		return ;
-	}
-#endif ///]
-
-
 	/* Free any LUTs that have completed */
 	for (i = 0; i < fb_data->num_luts; i++) {
 		if ((epdc_irq_stat & (1ULL << i)) == 0)
@@ -6292,26 +5697,6 @@ static void epdc_intr_work_func(struct work_struct *work)
 
 		epdc_clear_lut_complete_irq(fb_data->rev, i);
 
-		fb_data->luts_updating &= ~(u64)(1ULL<<i) ;
-#if 1
-		if(fb_data->lut_rect[i].width>fb_data->active_updating_w) {
-			dev_warn(fb_data->dev,"[WARN] cur update w(%d)>updating w(%d)\n",
-					fb_data->lut_rect[i].width,fb_data->active_updating_w);
-			fb_data->active_updating_w = 0;
-		}
-		else {
-			fb_data->active_updating_w -= fb_data->lut_rect[i].width;
-		}
-		if(fb_data->lut_rect[i].height>fb_data->active_updating_h) {
-			dev_warn(fb_data->dev,"[WARN] cur update h(%d)>updating h(%d)\n",
-					fb_data->lut_rect[i].height,fb_data->active_updating_h);
-			fb_data->active_updating_h = 0;
-		}
-		else {
-			fb_data->active_updating_h -= fb_data->lut_rect[i].height;
-		}
-#endif
-
 		fb_data->luts_complete_wb |= 1ULL << i;
 		if (i != 0)
 			fb_data->luts_complete |= 1ULL << i;
@@ -6376,9 +5761,6 @@ static void epdc_intr_work_func(struct work_struct *work)
 		GALLEN_DBGLOCAL_RUNLOG(4);
 		fb_data->updates_active = false;
 
-		fb_data->active_updating_h=0;
-		fb_data->active_updating_w=0;
-
 		if (fb_data->pwrdown_delay != FB_POWERDOWN_DISABLE) {
 			/*
 			 * Set variable to prevent overlapping
@@ -6417,7 +5799,6 @@ static void epdc_intr_work_func(struct work_struct *work)
 	 */
 	if (epdc_waiting_on_wb) {
 		dev_dbg(fb_data->dev, "\nWorking buffer completed\n");
-		EPDC_VPRINT(fb_data,3, "\nWorking buffer completed\n");
 
 		/* Signal completion if submit workqueue was waiting on WB */
 		if (fb_data->waiting_for_wb) {
@@ -6521,8 +5902,6 @@ static void epdc_intr_work_func(struct work_struct *work)
 			NTX_TimeStamp_printf("epdc_collision_mask",0,"collision mask=0x%llx",fb_data->epdc_colliding_luts);
 			dev_dbg(fb_data->dev, "Collision mask = 0x%llx\n",
 			       fb_data->epdc_colliding_luts);
-			EPDC_VPRINT(fb_data,3, "Collision mask = 0x%llx\n",
-			       fb_data->epdc_colliding_luts);
 
 			/* For EPDC 2.0 and later, minimum collision bounds
 			   are provided by HW.  Recompute new bounds here. */
@@ -6671,38 +6050,8 @@ static void epdc_intr_work_func(struct work_struct *work)
 					next_marker->lut_num = INVALID_LUT;
 
 				/* Move to collision list */
-				EPDC_VPRINT(fb_data,1,"lut%d re-setup for collision region ,flags=0x%x,upd_order=%d\n",
-						fb_data->cur_update->lut_num,
-						fb_data->cur_update->update_desc->upd_data.flags,
-						fb_data->cur_update->update_desc->update_order);
-
 				list_add_tail(&fb_data->cur_update->list,
 					 &fb_data->upd_buf_collision_list);
-#if (TCE_UNDERRUN_PREVENT_PATCH==1) // avoid TCE underrun after collision occurring . 
-				{
-					int i,iMaxWaitCnt=50;
-
-					EPDC_VPRINT(fb_data,1,"waiting for lut%d complete to re-send collision ...\n",
-							fb_data->lastest_lut_num);
-					
-					//mutex_unlock(&fb_data->queue_mutex);
-
-					for(i=0;i<iMaxWaitCnt;i++) {
-						if(epdc_is_lut_complete(fb_data->rev,fb_data->lastest_lut_num)) {
-							EPDC_VPRINT(fb_data,1,"lut%d complete !\n",fb_data->lastest_lut_num);
-							break;
-						}
-						msleep(10);
-					}
-					if(i>=iMaxWaitCnt) {
-						EPDC_VPRINT(fb_data,1,"[collision] waiting for lut%d complete timeout !!\n",fb_data->lastest_lut_num);
-					}
-					EPDC_VPRINT(fb_data,1,"[collision]lut%d wait %dms done, re-sending update !!\n",fb_data->lastest_lut_num,10*i);
-
-					//mutex_lock(&fb_data->queue_mutex);
-				}
-#endif//] (TCE_UNDERRUN_PREVENT_PATCH==1) 
-
 			}
 		}
 
@@ -7343,10 +6692,6 @@ static void mxc_epdc_fb_fw_handler(const struct firmware *fw,
 		}
 	}
 
-#ifdef FW_IN_RAM //[
-	fb_data->waveform_buffer_virt = gpbWF_vaddr + wv_data_offs;
-	fb_data->waveform_buffer_phys = gpbWF_paddr + wv_data_offs;
-#else // ][!FW_IN_RAM
 	/* Allocate memory for waveform data */
 	fb_data->waveform_buffer_virt = dma_alloc_coherent(fb_data->dev,
 						fb_data->waveform_buffer_size,
@@ -7359,8 +6704,6 @@ static void mxc_epdc_fb_fw_handler(const struct firmware *fw,
 
 	memcpy(fb_data->waveform_buffer_virt, (u8 *)(fw->data) + wv_data_offs,
 		fb_data->waveform_buffer_size);
-#endif //]FW_IN_RAM
-
 
 	/* Check for advanced algorithms */
 	if ((wv_file->wdh.luts & WAVEFORM_HDR_LUT_ADVANCED_ALGO_MASK) != 0) {
@@ -7747,66 +7090,14 @@ static int mxc_epdc_fb_probe(struct platform_device *pdev)
 		fb_data->cur_mode = &fb_data->pdata->epdc_mode[13];//
 		fb_data->dwSafeTicksEP3V3 = 900;
 	}
-	else if(15==gptHWCFG->m_val.bDisplayResolution) {
-		printk("%s(%d):EPD 1264x1680 \n",__FILE__,__LINE__);
-		fb_data->cur_mode = &fb_data->pdata->epdc_mode[15];//
-		fb_data->dwSafeTicksEP3V3 = 900;
-	}
 	else {
-		if (gptHWCFG->m_val.bPCB>=85) {
-			fb_data->cur_mode = &fb_data->pdata->epdc_mode[14];
-			fb_data->dwSafeTicksEP3V3 = 400;
-		}
-		else {
-			fb_data->cur_mode = &fb_data->pdata->epdc_mode[8];
-			fb_data->dwSafeTicksEP3V3 = 400;
-		}
+		fb_data->cur_mode = &fb_data->pdata->epdc_mode[8];
+		fb_data->dwSafeTicksEP3V3 = 400;
 	}
 #else
 	fb_data->cur_mode = &fb_data->pdata->epdc_mode[0];
 #endif
 
-#ifdef CONFIG_SOC_IMX6SLL //[
-	if(cpu_is_imx6sll()) {
-		extern void imx6sll_epdc_pre_sel(int iSelFreq);
-
-		if( fb_data->cur_mode->vmode->pixclock==135000000 ) //E70K02, special case
-		{
-			do {
-				// := 135MHz
-				// original parent clock is 320MHz . 
-				// change the parent clock to 540MHz . 
-				printk("%s():changing the epdc_pre_sel parent clock to 540MHz \n",__FUNCTION__);
-				imx6sll_epdc_pre_sel(540000000);
-			} while(0);
-		}
-		else if( fb_data->cur_mode->vmode->pixclock>=110000000 && 
-			 fb_data->cur_mode->vmode->pixclock<=140000000) 
-		{
-			do {
-				// := 133MHz
-				// original parent clock is 320MHz . 
-				// change the parent clock to 400MHz . 
-				printk("%s():changing the epdc_pre_sel parent clock to 400MHz \n",__FUNCTION__);
-				imx6sll_epdc_pre_sel(400000000); 
-			} while(0);
-		}
-		else
-		if( fb_data->cur_mode->vmode->pixclock>=87500000 && 
-			 fb_data->cur_mode->vmode->pixclock<=88500000) 
-		{
-			do {
-				// := 88MHz
-				// original parent clock is 320MHz . 
-				// change the parent clock to 528MHz . 
-				printk("%s():changing the epdc_pre_sel parent clock to 528MHz \n",__FUNCTION__);
-				imx6sll_epdc_pre_sel(528000000);
-			} while(0);
-		}
-	}
-#endif //] CONFIG_SOC_IMX6SLL
-
-
 	if (!of_property_read_u32(np, "safe-ticks-turnoff-ep3v3", &dwSafeTicksTurnoffEP3V3))
 	{
 		// safe-ticks-turnoff-ep3v3 property .
@@ -8020,11 +7311,63 @@ static int mxc_epdc_fb_probe(struct platform_device *pdev)
 	clk_prepare_enable(fb_data->epdc_clk_axi);
 	clk_prepare_enable(fb_data->epdc_clk_pix);
 	val = __raw_readl(EPDC_VERSION);
+#ifdef QOS_ENABLE //[
+	{
+		if( QOS_SOC_MX6SLL() || QOS_SOC_MX6SL() ) 
+		{
+			unsigned char *reg_qos_base;
+			unsigned long dwQoS_epdc_offset;
+			int iQoS_RD,iQoS_WR;
+			void __iomem *qosc_base;
+			//unsigned char *reg_qos_lcdif,*reg_qos_pxp;
 
-	if( QOS_SOC_MX6SLL() || QOS_SOC_MX6SL() ) {
-		_epdc_qos_setup();
-	}
+			if( QOS_SOC_MX6SLL() ) {
+				printk("EPDC QoS mx6sll \n");
+				reg_qos_base = 0x02094000;
+				dwQoS_epdc_offset = 0x1800;
+				//reg_qos_epdc = 0x02095800;
+				//reg_qos_lcdif = 0x02096000;
+				//reg_qos_pxp = 0x02095400;
+				iQoS_RD = 0xe0;
+				iQoS_WR = 0xd0;
+			}
+			else {
+				printk("EPDC QoS mx6sl \n");
+				reg_qos_base = 0x02094000;
+				dwQoS_epdc_offset = 0x1400;
+				//reg_qos_epdc = 0x02095400;
+				//reg_qos_lcdif = 0x02095800;
+				//reg_qos_pxp = 0x02095c00;
+				iQoS_RD = 0xe0;
+				iQoS_WR = 0xd0;
+			}
+
+			reg_qos_base = ioremap(reg_qos_base,SZ_16K);
+			if(reg_qos_base == NULL) {
+				ret = -ENOMEM;
+				printk(KERN_ERR"request qos memory failed !\n");
+				goto out;
+			}
+			else {
+
+				__raw_writel(0,reg_qos_base); // Disable clkgate & soft_reset .
+				__raw_writel(0,reg_qos_base+0x40); // Enable all masters .
+
+				__raw_writel(0,reg_qos_base+dwQoS_epdc_offset); // Disable clkgate & soft_reset .
+				printk ("[%s-%d] Old QoS_WR=%08X\n",__func__, __LINE__,__raw_readl(reg_qos_base+dwQoS_epdc_offset+iQoS_WR));
+				printk ("[%s-%d] Old QoS_RD=%08X\n",__func__, __LINE__,__raw_readl(reg_qos_base+dwQoS_epdc_offset+iQoS_RD));
+				__raw_writel(0x0f020722,reg_qos_base+dwQoS_epdc_offset+iQoS_WR); // Write QOS,init = 7 with red flag .
+				__raw_writel(0x0f020722,reg_qos_base+dwQoS_epdc_offset+iQoS_RD); // Read QOS, init = 7 with red flag .
+				printk ("[%s-%d] New QoS_WR=%08X\n",__func__, __LINE__,__raw_readl(reg_qos_base+dwQoS_epdc_offset+iQoS_WR));
+				printk ("[%s-%d] New QoS_RD=%08X\n",__func__, __LINE__,__raw_readl(reg_qos_base+dwQoS_epdc_offset+iQoS_RD));
 
+				__raw_readl(reg_qos_base+dwQoS_epdc_offset); // check the QOS value .
+
+				iounmap(reg_qos_base);
+			}
+		}
+	}
+#endif //]QOS_ENABLE
 	clk_disable_unprepare(fb_data->epdc_clk_pix);
 	clk_disable_unprepare(fb_data->epdc_clk_axi);
 	fb_data->rev = ((val & EPDC_VERSION_MAJOR_MASK) >>
@@ -8107,7 +7450,6 @@ static int mxc_epdc_fb_probe(struct platform_device *pdev)
 		goto out_upd_buffers;
 	}
 
-#ifdef EPDC_V2_ENABLE_HW_DITHER //[
 	fb_data->virt_addr_y4 =
 	    dma_alloc_coherent(fb_data->info.device, fb_data->max_pix_size*2,
 			       &fb_data->phys_addr_y4,
@@ -8116,7 +7458,6 @@ static int mxc_epdc_fb_probe(struct platform_device *pdev)
 		ret = -ENOMEM;
 		goto out_upd_buffers;
 	}
-#endif //]EPDC_V2_ENABLE_HW_DITHER
 
 	fb_data->virt_addr_y4c =
 	    dma_alloc_coherent(fb_data->info.device, fb_data->max_pix_size*2,
@@ -8205,7 +7546,9 @@ static int mxc_epdc_fb_probe(struct platform_device *pdev)
 	fb_data->latest_update_region.top = (__u32)-1;
 	fb_data->latest_update_region.width = (__u32)-1;
 	fb_data->latest_update_region.height = (__u32)-1;
+#ifdef ENABLE_EPDC_REUPDATE_WORK//[
 	INIT_DELAYED_WORK(&fb_data->epdc_reupdate_work, epdc_reupdate_work_func);
+#endif //]ENABLE_EPDC_REUPDATE_WORK
 	
 	INIT_DELAYED_WORK(&fb_data->epdc_done_work, epdc_done_work_func);
 	fb_data->epdc_submit_workqueue = alloc_workqueue("EPDC Submit",
@@ -8408,6 +7751,9 @@ static int mxc_epdc_fb_probe(struct platform_device *pdev)
 	fb_data->updates_active = false;
 	//fb_data->pwrdown_delay = 0;
 	fb_data->pwrdown_delay = 20;
+#ifdef ENABLE_EPDC_REUPDATE_WORK//[
+	fb_data->reupdate_delayms = 2000;// 2 secs .
+#endif //]ENABLE_EPDC_REUPDATE_WORK
 	
 	fake_s1d13522_parse_epd_cmdline();
 
@@ -8431,17 +7777,38 @@ static int mxc_epdc_fb_probe(struct platform_device *pdev)
 #endif
 
 
-	if( QOS_SOC_MX6ULL() ) {
-		_epdc_qos_setup();
+#ifdef QOS_ENABLE //[
+	{
+		if( QOS_SOC_MX6ULL() ) {
+			/* enable the QoS feature to make sure the EPDC has the highest priority. */
+			#define	MX6ULL_GPV0_BASE_ADDR	0x00B00000
+			#define	MX6ULL_PXP_OFFSET_ADDR	69*0x1000
+			#define	MX6ULL_CSI_OFFSET_ADDR	70*0x1000
+			#define	MX6ULL_LCD_OFFSET_ADDR	71*0x1000
+			#define	MX6ULL_EPD_OFFSET_ADDR	72*0x1000
+
+			#define	MX6ULL_QOS_RD	0x100
+			#define	MX6ULL_QOS_WR	0x104
+			void __iomem *nic301_base;
+			nic301_base = ioremap(MX6ULL_GPV0_BASE_ADDR, SZ_1M);
+			if (nic301_base == NULL) {
+				ret = -ENOMEM;
+				goto out;
+			} else {
+				__raw_writel(0x7, nic301_base + MX6ULL_EPD_OFFSET_ADDR  + MX6ULL_QOS_WR); //default 2
+				__raw_writel(0x7, nic301_base + MX6ULL_EPD_OFFSET_ADDR  + MX6ULL_QOS_RD); //default 2
+
+				printk("EPD QOS_WR 0x%x, QOS_RD 0x%x\n",
+				__raw_readl( nic301_base + MX6ULL_EPD_OFFSET_ADDR  + MX6ULL_QOS_WR),
+				__raw_readl( nic301_base + MX6ULL_EPD_OFFSET_ADDR  + MX6ULL_QOS_RD));
+			}
+			
+		}
+		else {
+			printk(KERN_ERR"EPDC_QoS not supported on this platform !\n");
+		}
 	}
-#ifdef TCE_UNDERRUN_PREVENT_WORKFUNC//[
-	INIT_DELAYED_WORK(&fb_data->tce_safe_work, tce_safe_work_func);
-	fb_data->tce_safe_ms = TCE_UNDERRUN_PREVENT_WORKFUNC_BUSYMS;
-	fb_data->tce_safe_freems = TCE_UNDERRUN_PREVENT_WORKFUNC_FREEMS;
-	fb_data->tce_safe_loops = TCE_UNDERRUN_PREVENT_WORKFUNC_LOOPCNT;
-	fb_data->tce_safe_work_running = 0;
-	fb_data->tce_safe_lock=__SPIN_LOCK_UNLOCKED(fb_data->tce_safe_lock);
-#endif //]TCE_UNDERRUN_PREVENT_WORKFUNC
+#endif //] QOS_ENABLE
 
 	k_fake_s1d13522_init((unsigned char*)gpbLOGO_vaddr);
 	goto out;
@@ -8512,13 +7879,10 @@ static int mxc_epdc_fb_remove(struct platform_device *pdev)
 	dma_free_writecombine(&pdev->dev, fb_data->working_buffer_size,
 				fb_data->working_buffer_virt,
 				fb_data->working_buffer_phys);
-#ifdef FW_IN_RAM //[
-#else //][! FW_IN_RAM
 	if (fb_data->waveform_buffer_virt != NULL)
 		dma_free_writecombine(&pdev->dev, fb_data->waveform_buffer_size,
 				fb_data->waveform_buffer_virt,
 				fb_data->waveform_buffer_phys);
-#endif //] FW_IN_RAM
 	if (fb_data->virt_addr_copybuf != NULL)
 		dma_free_writecombine(&pdev->dev, fb_data->max_pix_size*2,
 				fb_data->virt_addr_copybuf,
@@ -8601,23 +7965,14 @@ static int mxc_epdc_fb_resume(struct device *dev)
 {
 	struct mxc_epdc_fb_data *data = dev_get_drvdata(dev);
 
+	ntx_epdc_resume();
 	pinctrl_pm_select_default_state(dev);
-	
 #ifdef EPD_SUSPEND_BLANK//[
 	mxc_epdc_fb_blank(FB_BLANK_UNBLANK, &data->info);
 #endif //]EPD_SUSPEND_BLANK
 	epdc_init_settings(data);
 	data->updates_active = false;
 
-#ifdef QOS_ENABLE//[
-	clk_prepare_enable(data->epdc_clk_axi);
-	clk_prepare_enable(data->epdc_clk_pix);
-	_epdc_qos_setup();
-	clk_disable_unprepare(data->epdc_clk_pix);
-	clk_disable_unprepare(data->epdc_clk_axi);
-#endif QOS_ENABLE//]
-
-	ntx_epdc_resume();
 	return 0;
 }
 #else
@@ -9095,7 +8450,6 @@ static int pxp_legacy_process(struct mxc_epdc_fb_data *fb_data,
 
 	return 0;
 }
-#ifdef EPDC_V2_ENABLE_HW_DITHER //[
 
 static int pxp_process_dithering(struct mxc_epdc_fb_data *fb_data,
 			      struct mxcfb_rect *update_region)
@@ -9236,10 +8590,6 @@ static int pxp_process_dithering(struct mxc_epdc_fb_data *fb_data,
 
 	return 0;
 }
-#else //][!EPDC_V2_ENABLE_HW_DITHER
-static int pxp_process_dithering(struct mxc_epdc_fb_data *fb_data,
-			      struct mxcfb_rect *update_region) {return 0;}
-#endif //] EPDC_V2_ENABLE_HW_DITHER
 
 /*
  * Function to call PxP DMA driver and send our latest FB update region
@@ -9344,13 +8694,9 @@ static int pxp_wfe_a_process(struct mxc_epdc_fb_data *fb_data,
 	/* upd buffer left and top should be always 0 */
 	pxp_conf->wfe_a_fetch_param[0].left = 0;
 	pxp_conf->wfe_a_fetch_param[0].top = 0;
-#ifdef EPDC_V2_ENABLE_HW_DITHER //[
 	if (proc_data->dither_mode) {
 		pxp_conf->wfe_a_fetch_param[0].paddr = fb_data->phys_addr_y4;
-	} 
-	else 
-#endif //] EPDC_V2_ENABLE_HW_DITHER
-	{
+	} else {
 		is_transform = ((upd_data_list->update_desc->upd_data.flags &
 			(EPDC_FLAG_ENABLE_INVERSION | EPDC_FLAG_USE_DITHERING_Y1 |
 			EPDC_FLAG_USE_DITHERING_Y4 | EPDC_FLAG_FORCE_MONOCHROME |
-- 
2.30.2

